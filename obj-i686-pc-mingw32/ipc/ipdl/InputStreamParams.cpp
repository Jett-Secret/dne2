//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/ipc/InputStreamParams.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct StringInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT StringInputStreamParams::StringInputStreamParams() :
    data_()
{
    Init();
}

StringInputStreamParams::~StringInputStreamParams()
{
}

auto StringInputStreamParams::operator==(const StringInputStreamParams& _o) const -> bool
{
    if ((!((data()) == ((_o).data())))) {
        return false;
    }
    return true;
}

auto StringInputStreamParams::Init() -> void
{
}

auto StringInputStreamParams::Assign(const nsCString& _data) -> void
{
    data_ = _data;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct FileInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT FileInputStreamParams::FileInputStreamParams() :
    fileDescriptorIndex_(),
    behaviorFlags_(),
    ioFlags_()
{
    Init();
}

FileInputStreamParams::~FileInputStreamParams()
{
}

auto FileInputStreamParams::operator==(const FileInputStreamParams& _o) const -> bool
{
    if ((!((fileDescriptorIndex()) == ((_o).fileDescriptorIndex())))) {
        return false;
    }
    if ((!((behaviorFlags()) == ((_o).behaviorFlags())))) {
        return false;
    }
    if ((!((ioFlags()) == ((_o).ioFlags())))) {
        return false;
    }
    return true;
}

auto FileInputStreamParams::Init() -> void
{
}

auto FileInputStreamParams::Assign(
        const uint32_t& _fileDescriptorIndex,
        const int32_t& _behaviorFlags,
        const int32_t& _ioFlags) -> void
{
    fileDescriptorIndex_ = _fileDescriptorIndex;
    behaviorFlags_ = _behaviorFlags;
    ioFlags_ = _ioFlags;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct PartialFileInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT PartialFileInputStreamParams::PartialFileInputStreamParams() :
    begin_(),
    length_()
{
    Init();
}

PartialFileInputStreamParams::~PartialFileInputStreamParams()
{
}

auto PartialFileInputStreamParams::operator==(const PartialFileInputStreamParams& _o) const -> bool
{
    if ((!((fileStreamParams()) == ((_o).fileStreamParams())))) {
        return false;
    }
    if ((!((begin()) == ((_o).begin())))) {
        return false;
    }
    if ((!((length()) == ((_o).length())))) {
        return false;
    }
    return true;
}

auto PartialFileInputStreamParams::Init() -> void
{
}

auto PartialFileInputStreamParams::Assign(
        const FileInputStreamParams& _fileStreamParams,
        const uint64_t& _begin,
        const uint64_t& _length) -> void
{
    fileStreamParams_ = _fileStreamParams;
    begin_ = _begin;
    length_ = _length;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct TemporaryFileInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT TemporaryFileInputStreamParams::TemporaryFileInputStreamParams() :
    fileDescriptorIndex_(),
    startPos_(),
    endPos_()
{
    Init();
}

TemporaryFileInputStreamParams::~TemporaryFileInputStreamParams()
{
}

auto TemporaryFileInputStreamParams::operator==(const TemporaryFileInputStreamParams& _o) const -> bool
{
    if ((!((fileDescriptorIndex()) == ((_o).fileDescriptorIndex())))) {
        return false;
    }
    if ((!((startPos()) == ((_o).startPos())))) {
        return false;
    }
    if ((!((endPos()) == ((_o).endPos())))) {
        return false;
    }
    return true;
}

auto TemporaryFileInputStreamParams::Init() -> void
{
}

auto TemporaryFileInputStreamParams::Assign(
        const uint32_t& _fileDescriptorIndex,
        const uint64_t& _startPos,
        const uint64_t& _endPos) -> void
{
    fileDescriptorIndex_ = _fileDescriptorIndex;
    startPos_ = _startPos;
    endPos_ = _endPos;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct MultiplexInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT MultiplexInputStreamParams::MultiplexInputStreamParams() :
    currentStream_(),
    status_(),
    startedReadingCurrent_()
{
    Init();
}

MultiplexInputStreamParams::~MultiplexInputStreamParams()
{
    delete streams_;
}

auto MultiplexInputStreamParams::operator==(const MultiplexInputStreamParams& _o) const -> bool
{
    if ((!((streams()) == ((_o).streams())))) {
        return false;
    }
    if ((!((currentStream()) == ((_o).currentStream())))) {
        return false;
    }
    if ((!((status()) == ((_o).status())))) {
        return false;
    }
    if ((!((startedReadingCurrent()) == ((_o).startedReadingCurrent())))) {
        return false;
    }
    return true;
}

auto MultiplexInputStreamParams::Init() -> void
{
    streams_ = new nsTArray<InputStreamParams>();
}

auto MultiplexInputStreamParams::Assign(
        const nsTArray<InputStreamParams>& _streams,
        const uint32_t& _currentStream,
        const nsresult& _status,
        const bool& _startedReadingCurrent) -> void
{
    (*(streams_)) = _streams;
    currentStream_ = _currentStream;
    status_ = _status;
    startedReadingCurrent_ = _startedReadingCurrent;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct RemoteInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT RemoteInputStreamParams::RemoteInputStreamParams() :
    id_()
{
    Init();
}

RemoteInputStreamParams::~RemoteInputStreamParams()
{
}

auto RemoteInputStreamParams::operator==(const RemoteInputStreamParams& _o) const -> bool
{
    if ((!((id()) == ((_o).id())))) {
        return false;
    }
    return true;
}

auto RemoteInputStreamParams::Init() -> void
{
}

auto RemoteInputStreamParams::Assign(const nsID& _id) -> void
{
    id_ = _id;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SameProcessInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT SameProcessInputStreamParams::SameProcessInputStreamParams() :
    addRefedInputStream_()
{
    Init();
}

SameProcessInputStreamParams::~SameProcessInputStreamParams()
{
}

auto SameProcessInputStreamParams::operator==(const SameProcessInputStreamParams& _o) const -> bool
{
    if ((!((addRefedInputStream()) == ((_o).addRefedInputStream())))) {
        return false;
    }
    return true;
}

auto SameProcessInputStreamParams::Init() -> void
{
}

auto SameProcessInputStreamParams::Assign(const intptr_t& _addRefedInputStream) -> void
{
    addRefedInputStream_ = _addRefedInputStream;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union InputStreamParams|
//
namespace mozilla {
namespace ipc {
auto InputStreamParams::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TStringInputStreamParams:
        {
            (ptr_StringInputStreamParams())->~StringInputStreamParams__tdef();
            break;
        }
    case TFileInputStreamParams:
        {
            (ptr_FileInputStreamParams())->~FileInputStreamParams__tdef();
            break;
        }
    case TPartialFileInputStreamParams:
        {
            (ptr_PartialFileInputStreamParams())->~PartialFileInputStreamParams__tdef();
            break;
        }
    case TTemporaryFileInputStreamParams:
        {
            (ptr_TemporaryFileInputStreamParams())->~TemporaryFileInputStreamParams__tdef();
            break;
        }
    case TBufferedInputStreamParams:
        {
            delete ptr_BufferedInputStreamParams();
            break;
        }
    case TMIMEInputStreamParams:
        {
            delete ptr_MIMEInputStreamParams();
            break;
        }
    case TMultiplexInputStreamParams:
        {
            delete ptr_MultiplexInputStreamParams();
            break;
        }
    case TRemoteInputStreamParams:
        {
            (ptr_RemoteInputStreamParams())->~RemoteInputStreamParams__tdef();
            break;
        }
    case TSameProcessInputStreamParams:
        {
            (ptr_SameProcessInputStreamParams())->~SameProcessInputStreamParams__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const StringInputStreamParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_StringInputStreamParams()) StringInputStreamParams(aOther);
    mType = TStringInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const FileInputStreamParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_FileInputStreamParams()) FileInputStreamParams(aOther);
    mType = TFileInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const PartialFileInputStreamParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_PartialFileInputStreamParams()) PartialFileInputStreamParams(aOther);
    mType = TPartialFileInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const TemporaryFileInputStreamParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_TemporaryFileInputStreamParams()) TemporaryFileInputStreamParams(aOther);
    mType = TTemporaryFileInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const BufferedInputStreamParams& aOther)
{
    ptr_BufferedInputStreamParams() = new BufferedInputStreamParams(aOther);
    mType = TBufferedInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const MIMEInputStreamParams& aOther)
{
    ptr_MIMEInputStreamParams() = new MIMEInputStreamParams(aOther);
    mType = TMIMEInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const MultiplexInputStreamParams& aOther)
{
    ptr_MultiplexInputStreamParams() = new MultiplexInputStreamParams(aOther);
    mType = TMultiplexInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const RemoteInputStreamParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_RemoteInputStreamParams()) RemoteInputStreamParams(aOther);
    mType = TRemoteInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const SameProcessInputStreamParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_SameProcessInputStreamParams()) SameProcessInputStreamParams(aOther);
    mType = TSameProcessInputStreamParams;
}

MOZ_IMPLICIT InputStreamParams::InputStreamParams(const InputStreamParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TStringInputStreamParams:
        {
            new (mozilla::KnownNotNull, ptr_StringInputStreamParams()) StringInputStreamParams((aOther).get_StringInputStreamParams());
            break;
        }
    case TFileInputStreamParams:
        {
            new (mozilla::KnownNotNull, ptr_FileInputStreamParams()) FileInputStreamParams((aOther).get_FileInputStreamParams());
            break;
        }
    case TPartialFileInputStreamParams:
        {
            new (mozilla::KnownNotNull, ptr_PartialFileInputStreamParams()) PartialFileInputStreamParams((aOther).get_PartialFileInputStreamParams());
            break;
        }
    case TTemporaryFileInputStreamParams:
        {
            new (mozilla::KnownNotNull, ptr_TemporaryFileInputStreamParams()) TemporaryFileInputStreamParams((aOther).get_TemporaryFileInputStreamParams());
            break;
        }
    case TBufferedInputStreamParams:
        {
            ptr_BufferedInputStreamParams() = new BufferedInputStreamParams((aOther).get_BufferedInputStreamParams());
            break;
        }
    case TMIMEInputStreamParams:
        {
            ptr_MIMEInputStreamParams() = new MIMEInputStreamParams((aOther).get_MIMEInputStreamParams());
            break;
        }
    case TMultiplexInputStreamParams:
        {
            ptr_MultiplexInputStreamParams() = new MultiplexInputStreamParams((aOther).get_MultiplexInputStreamParams());
            break;
        }
    case TRemoteInputStreamParams:
        {
            new (mozilla::KnownNotNull, ptr_RemoteInputStreamParams()) RemoteInputStreamParams((aOther).get_RemoteInputStreamParams());
            break;
        }
    case TSameProcessInputStreamParams:
        {
            new (mozilla::KnownNotNull, ptr_SameProcessInputStreamParams()) SameProcessInputStreamParams((aOther).get_SameProcessInputStreamParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

InputStreamParams::~InputStreamParams()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto InputStreamParams::operator=(const StringInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TStringInputStreamParams)) {
        new (mozilla::KnownNotNull, ptr_StringInputStreamParams()) StringInputStreamParams;
    }
    (*(ptr_StringInputStreamParams())) = aRhs;
    mType = TStringInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const FileInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TFileInputStreamParams)) {
        new (mozilla::KnownNotNull, ptr_FileInputStreamParams()) FileInputStreamParams;
    }
    (*(ptr_FileInputStreamParams())) = aRhs;
    mType = TFileInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const PartialFileInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TPartialFileInputStreamParams)) {
        new (mozilla::KnownNotNull, ptr_PartialFileInputStreamParams()) PartialFileInputStreamParams;
    }
    (*(ptr_PartialFileInputStreamParams())) = aRhs;
    mType = TPartialFileInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const TemporaryFileInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TTemporaryFileInputStreamParams)) {
        new (mozilla::KnownNotNull, ptr_TemporaryFileInputStreamParams()) TemporaryFileInputStreamParams;
    }
    (*(ptr_TemporaryFileInputStreamParams())) = aRhs;
    mType = TTemporaryFileInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const BufferedInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TBufferedInputStreamParams)) {
        ptr_BufferedInputStreamParams() = new BufferedInputStreamParams;
    }
    (*(ptr_BufferedInputStreamParams())) = aRhs;
    mType = TBufferedInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const MIMEInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TMIMEInputStreamParams)) {
        ptr_MIMEInputStreamParams() = new MIMEInputStreamParams;
    }
    (*(ptr_MIMEInputStreamParams())) = aRhs;
    mType = TMIMEInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const MultiplexInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TMultiplexInputStreamParams)) {
        ptr_MultiplexInputStreamParams() = new MultiplexInputStreamParams;
    }
    (*(ptr_MultiplexInputStreamParams())) = aRhs;
    mType = TMultiplexInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const RemoteInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TRemoteInputStreamParams)) {
        new (mozilla::KnownNotNull, ptr_RemoteInputStreamParams()) RemoteInputStreamParams;
    }
    (*(ptr_RemoteInputStreamParams())) = aRhs;
    mType = TRemoteInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const SameProcessInputStreamParams& aRhs) -> InputStreamParams&
{
    if (MaybeDestroy(TSameProcessInputStreamParams)) {
        new (mozilla::KnownNotNull, ptr_SameProcessInputStreamParams()) SameProcessInputStreamParams;
    }
    (*(ptr_SameProcessInputStreamParams())) = aRhs;
    mType = TSameProcessInputStreamParams;
    return (*(this));
}

auto InputStreamParams::operator=(const InputStreamParams& aRhs) -> InputStreamParams&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TStringInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_StringInputStreamParams()) StringInputStreamParams;
            }
            (*(ptr_StringInputStreamParams())) = (aRhs).get_StringInputStreamParams();
            break;
        }
    case TFileInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_FileInputStreamParams()) FileInputStreamParams;
            }
            (*(ptr_FileInputStreamParams())) = (aRhs).get_FileInputStreamParams();
            break;
        }
    case TPartialFileInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PartialFileInputStreamParams()) PartialFileInputStreamParams;
            }
            (*(ptr_PartialFileInputStreamParams())) = (aRhs).get_PartialFileInputStreamParams();
            break;
        }
    case TTemporaryFileInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_TemporaryFileInputStreamParams()) TemporaryFileInputStreamParams;
            }
            (*(ptr_TemporaryFileInputStreamParams())) = (aRhs).get_TemporaryFileInputStreamParams();
            break;
        }
    case TBufferedInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                ptr_BufferedInputStreamParams() = new BufferedInputStreamParams;
            }
            (*(ptr_BufferedInputStreamParams())) = (aRhs).get_BufferedInputStreamParams();
            break;
        }
    case TMIMEInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                ptr_MIMEInputStreamParams() = new MIMEInputStreamParams;
            }
            (*(ptr_MIMEInputStreamParams())) = (aRhs).get_MIMEInputStreamParams();
            break;
        }
    case TMultiplexInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                ptr_MultiplexInputStreamParams() = new MultiplexInputStreamParams;
            }
            (*(ptr_MultiplexInputStreamParams())) = (aRhs).get_MultiplexInputStreamParams();
            break;
        }
    case TRemoteInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_RemoteInputStreamParams()) RemoteInputStreamParams;
            }
            (*(ptr_RemoteInputStreamParams())) = (aRhs).get_RemoteInputStreamParams();
            break;
        }
    case TSameProcessInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SameProcessInputStreamParams()) SameProcessInputStreamParams;
            }
            (*(ptr_SameProcessInputStreamParams())) = (aRhs).get_SameProcessInputStreamParams();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto InputStreamParams::operator==(const StringInputStreamParams& aRhs) const -> bool
{
    return (get_StringInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const FileInputStreamParams& aRhs) const -> bool
{
    return (get_FileInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const PartialFileInputStreamParams& aRhs) const -> bool
{
    return (get_PartialFileInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const TemporaryFileInputStreamParams& aRhs) const -> bool
{
    return (get_TemporaryFileInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const BufferedInputStreamParams& aRhs) const -> bool
{
    return (get_BufferedInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const MIMEInputStreamParams& aRhs) const -> bool
{
    return (get_MIMEInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const MultiplexInputStreamParams& aRhs) const -> bool
{
    return (get_MultiplexInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const RemoteInputStreamParams& aRhs) const -> bool
{
    return (get_RemoteInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const SameProcessInputStreamParams& aRhs) const -> bool
{
    return (get_SameProcessInputStreamParams()) == (aRhs);
}

auto InputStreamParams::operator==(const InputStreamParams& aRhs) const -> bool
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TStringInputStreamParams:
        {
            return (get_StringInputStreamParams()) == ((aRhs).get_StringInputStreamParams());
        }
    case TFileInputStreamParams:
        {
            return (get_FileInputStreamParams()) == ((aRhs).get_FileInputStreamParams());
        }
    case TPartialFileInputStreamParams:
        {
            return (get_PartialFileInputStreamParams()) == ((aRhs).get_PartialFileInputStreamParams());
        }
    case TTemporaryFileInputStreamParams:
        {
            return (get_TemporaryFileInputStreamParams()) == ((aRhs).get_TemporaryFileInputStreamParams());
        }
    case TBufferedInputStreamParams:
        {
            return (get_BufferedInputStreamParams()) == ((aRhs).get_BufferedInputStreamParams());
        }
    case TMIMEInputStreamParams:
        {
            return (get_MIMEInputStreamParams()) == ((aRhs).get_MIMEInputStreamParams());
        }
    case TMultiplexInputStreamParams:
        {
            return (get_MultiplexInputStreamParams()) == ((aRhs).get_MultiplexInputStreamParams());
        }
    case TRemoteInputStreamParams:
        {
            return (get_RemoteInputStreamParams()) == ((aRhs).get_RemoteInputStreamParams());
        }
    case TSameProcessInputStreamParams:
        {
            return (get_SameProcessInputStreamParams()) == ((aRhs).get_SameProcessInputStreamParams());
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return false;
        }
    }
}

auto InputStreamParams::get(StringInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_StringInputStreamParams();
}

auto InputStreamParams::get(FileInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_FileInputStreamParams();
}

auto InputStreamParams::get(PartialFileInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_PartialFileInputStreamParams();
}

auto InputStreamParams::get(TemporaryFileInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_TemporaryFileInputStreamParams();
}

auto InputStreamParams::get(BufferedInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_BufferedInputStreamParams();
}

auto InputStreamParams::get(MIMEInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_MIMEInputStreamParams();
}

auto InputStreamParams::get(MultiplexInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_MultiplexInputStreamParams();
}

auto InputStreamParams::get(RemoteInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_RemoteInputStreamParams();
}

auto InputStreamParams::get(SameProcessInputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_SameProcessInputStreamParams();
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalInputStreamParams|
//
namespace mozilla {
namespace ipc {
auto OptionalInputStreamParams::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    case TInputStreamParams:
        {
            delete ptr_InputStreamParams();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT OptionalInputStreamParams::OptionalInputStreamParams(const void_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

MOZ_IMPLICIT OptionalInputStreamParams::OptionalInputStreamParams(const InputStreamParams& aOther)
{
    ptr_InputStreamParams() = new InputStreamParams(aOther);
    mType = TInputStreamParams;
}

MOZ_IMPLICIT OptionalInputStreamParams::OptionalInputStreamParams(const OptionalInputStreamParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case TInputStreamParams:
        {
            ptr_InputStreamParams() = new InputStreamParams((aOther).get_InputStreamParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OptionalInputStreamParams::~OptionalInputStreamParams()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto OptionalInputStreamParams::operator=(const void_t& aRhs) -> OptionalInputStreamParams&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

auto OptionalInputStreamParams::operator=(const InputStreamParams& aRhs) -> OptionalInputStreamParams&
{
    if (MaybeDestroy(TInputStreamParams)) {
        ptr_InputStreamParams() = new InputStreamParams;
    }
    (*(ptr_InputStreamParams())) = aRhs;
    mType = TInputStreamParams;
    return (*(this));
}

auto OptionalInputStreamParams::operator=(const OptionalInputStreamParams& aRhs) -> OptionalInputStreamParams&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case TInputStreamParams:
        {
            if (MaybeDestroy(t)) {
                ptr_InputStreamParams() = new InputStreamParams;
            }
            (*(ptr_InputStreamParams())) = (aRhs).get_InputStreamParams();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto OptionalInputStreamParams::operator==(const void_t& aRhs) const -> bool
{
    return (get_void_t()) == (aRhs);
}

auto OptionalInputStreamParams::operator==(const InputStreamParams& aRhs) const -> bool
{
    return (get_InputStreamParams()) == (aRhs);
}

auto OptionalInputStreamParams::operator==(const OptionalInputStreamParams& aRhs) const -> bool
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tvoid_t:
        {
            return (get_void_t()) == ((aRhs).get_void_t());
        }
    case TInputStreamParams:
        {
            return (get_InputStreamParams()) == ((aRhs).get_InputStreamParams());
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return false;
        }
    }
}

auto OptionalInputStreamParams::get(void_t* aOutValue) const -> void
{
    (*(aOutValue)) = get_void_t();
}

auto OptionalInputStreamParams::get(InputStreamParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_InputStreamParams();
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct BufferedInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT BufferedInputStreamParams::BufferedInputStreamParams() :
    bufferSize_()
{
    Init();
}

BufferedInputStreamParams::~BufferedInputStreamParams()
{
    delete optionalStream_;
}

auto BufferedInputStreamParams::operator==(const BufferedInputStreamParams& _o) const -> bool
{
    if ((!((optionalStream()) == ((_o).optionalStream())))) {
        return false;
    }
    if ((!((bufferSize()) == ((_o).bufferSize())))) {
        return false;
    }
    return true;
}

auto BufferedInputStreamParams::Init() -> void
{
    optionalStream_ = new OptionalInputStreamParams();
}

auto BufferedInputStreamParams::Assign(
        const OptionalInputStreamParams& _optionalStream,
        const uint32_t& _bufferSize) -> void
{
    (*(optionalStream_)) = _optionalStream;
    bufferSize_ = _bufferSize;
}

} // namespace ipc
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct MIMEInputStreamParams|
//
namespace mozilla {
namespace ipc {
MOZ_IMPLICIT MIMEInputStreamParams::MIMEInputStreamParams() :
    headers_(),
    contentLength_(),
    startedReading_(),
    addContentLength_()
{
    Init();
}

MIMEInputStreamParams::~MIMEInputStreamParams()
{
    delete optionalStream_;
}

auto MIMEInputStreamParams::operator==(const MIMEInputStreamParams& _o) const -> bool
{
    if ((!((optionalStream()) == ((_o).optionalStream())))) {
        return false;
    }
    if ((!((headers()) == ((_o).headers())))) {
        return false;
    }
    if ((!((contentLength()) == ((_o).contentLength())))) {
        return false;
    }
    if ((!((startedReading()) == ((_o).startedReading())))) {
        return false;
    }
    if ((!((addContentLength()) == ((_o).addContentLength())))) {
        return false;
    }
    return true;
}

auto MIMEInputStreamParams::Init() -> void
{
    optionalStream_ = new OptionalInputStreamParams();
}

auto MIMEInputStreamParams::Assign(
        const OptionalInputStreamParams& _optionalStream,
        const nsCString& _headers,
        const nsCString& _contentLength,
        const bool& _startedReading,
        const bool& _addContentLength) -> void
{
    (*(optionalStream_)) = _optionalStream;
    headers_ = _headers;
    contentLength_ = _contentLength;
    startedReading_ = _startedReading;
    addContentLength_ = _addContentLength;
}

} // namespace ipc
} // namespace mozilla
