//
// Automatically generated by ipdlc.
// Edit at your own risk
//


#include "mozilla/dom/indexedDB/PBackgroundIDBSharedTypes.h"


//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SerializedKeyRange|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT SerializedKeyRange::SerializedKeyRange() :
    lower_(),
    upper_(),
    lowerOpen_(),
    upperOpen_(),
    isOnly_()
{
    Init();
}

SerializedKeyRange::~SerializedKeyRange()
{
}

auto SerializedKeyRange::operator==(const SerializedKeyRange& _o) const -> bool
{
    if ((!((lower()) == ((_o).lower())))) {
        return false;
    }
    if ((!((upper()) == ((_o).upper())))) {
        return false;
    }
    if ((!((lowerOpen()) == ((_o).lowerOpen())))) {
        return false;
    }
    if ((!((upperOpen()) == ((_o).upperOpen())))) {
        return false;
    }
    if ((!((isOnly()) == ((_o).isOnly())))) {
        return false;
    }
    return true;
}

auto SerializedKeyRange::Init() -> void
{
}

auto SerializedKeyRange::Assign(
        const Key& _lower,
        const Key& _upper,
        const bool& _lowerOpen,
        const bool& _upperOpen,
        const bool& _isOnly) -> void
{
    lower_ = _lower;
    upper_ = _upper;
    lowerOpen_ = _lowerOpen;
    upperOpen_ = _upperOpen;
    isOnly_ = _isOnly;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union BlobOrMutableFile|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
auto BlobOrMutableFile::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case Tnull_t:
        {
            (ptr_null_t())->~null_t__tdef();
            break;
        }
    case TPBlobParent:
        {
            (ptr_PBlobParent())->~PBlobParent__tdef();
            break;
        }
    case TPBlobChild:
        {
            (ptr_PBlobChild())->~PBlobChild__tdef();
            break;
        }
    case TPBackgroundMutableFileParent:
        {
            (ptr_PBackgroundMutableFileParent())->~PBackgroundMutableFileParent__tdef();
            break;
        }
    case TPBackgroundMutableFileChild:
        {
            (ptr_PBackgroundMutableFileChild())->~PBackgroundMutableFileChild__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT BlobOrMutableFile::BlobOrMutableFile(const null_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_null_t()) null_t(aOther);
    mType = Tnull_t;
}

MOZ_IMPLICIT BlobOrMutableFile::BlobOrMutableFile(PBlobParent* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBlobParent()) PBlobParent*(const_cast<PBlobParent*>(aOther));
    mType = TPBlobParent;
}

MOZ_IMPLICIT BlobOrMutableFile::BlobOrMutableFile(PBlobChild* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBlobChild()) PBlobChild*(const_cast<PBlobChild*>(aOther));
    mType = TPBlobChild;
}

MOZ_IMPLICIT BlobOrMutableFile::BlobOrMutableFile(PBackgroundMutableFileParent* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*(const_cast<PBackgroundMutableFileParent*>(aOther));
    mType = TPBackgroundMutableFileParent;
}

MOZ_IMPLICIT BlobOrMutableFile::BlobOrMutableFile(PBackgroundMutableFileChild* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*(const_cast<PBackgroundMutableFileChild*>(aOther));
    mType = TPBackgroundMutableFileChild;
}

MOZ_IMPLICIT BlobOrMutableFile::BlobOrMutableFile(const BlobOrMutableFile& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case Tnull_t:
        {
            new (mozilla::KnownNotNull, ptr_null_t()) null_t((aOther).get_null_t());
            break;
        }
    case TPBlobParent:
        {
            new (mozilla::KnownNotNull, ptr_PBlobParent()) PBlobParent*(const_cast<PBlobParent*>((aOther).get_PBlobParent()));
            break;
        }
    case TPBlobChild:
        {
            new (mozilla::KnownNotNull, ptr_PBlobChild()) PBlobChild*(const_cast<PBlobChild*>((aOther).get_PBlobChild()));
            break;
        }
    case TPBackgroundMutableFileParent:
        {
            new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*(const_cast<PBackgroundMutableFileParent*>((aOther).get_PBackgroundMutableFileParent()));
            break;
        }
    case TPBackgroundMutableFileChild:
        {
            new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*(const_cast<PBackgroundMutableFileChild*>((aOther).get_PBackgroundMutableFileChild()));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

BlobOrMutableFile::~BlobOrMutableFile()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto BlobOrMutableFile::operator=(const null_t& aRhs) -> BlobOrMutableFile&
{
    if (MaybeDestroy(Tnull_t)) {
        new (mozilla::KnownNotNull, ptr_null_t()) null_t;
    }
    (*(ptr_null_t())) = aRhs;
    mType = Tnull_t;
    return (*(this));
}

auto BlobOrMutableFile::operator=(PBlobParent* aRhs) -> BlobOrMutableFile&
{
    if (MaybeDestroy(TPBlobParent)) {
        new (mozilla::KnownNotNull, ptr_PBlobParent()) PBlobParent*;
    }
    (*(ptr_PBlobParent())) = const_cast<PBlobParent*>(aRhs);
    mType = TPBlobParent;
    return (*(this));
}

auto BlobOrMutableFile::operator=(PBlobChild* aRhs) -> BlobOrMutableFile&
{
    if (MaybeDestroy(TPBlobChild)) {
        new (mozilla::KnownNotNull, ptr_PBlobChild()) PBlobChild*;
    }
    (*(ptr_PBlobChild())) = const_cast<PBlobChild*>(aRhs);
    mType = TPBlobChild;
    return (*(this));
}

auto BlobOrMutableFile::operator=(PBackgroundMutableFileParent* aRhs) -> BlobOrMutableFile&
{
    if (MaybeDestroy(TPBackgroundMutableFileParent)) {
        new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*;
    }
    (*(ptr_PBackgroundMutableFileParent())) = const_cast<PBackgroundMutableFileParent*>(aRhs);
    mType = TPBackgroundMutableFileParent;
    return (*(this));
}

auto BlobOrMutableFile::operator=(PBackgroundMutableFileChild* aRhs) -> BlobOrMutableFile&
{
    if (MaybeDestroy(TPBackgroundMutableFileChild)) {
        new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*;
    }
    (*(ptr_PBackgroundMutableFileChild())) = const_cast<PBackgroundMutableFileChild*>(aRhs);
    mType = TPBackgroundMutableFileChild;
    return (*(this));
}

auto BlobOrMutableFile::operator=(const BlobOrMutableFile& aRhs) -> BlobOrMutableFile&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case Tnull_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_null_t()) null_t;
            }
            (*(ptr_null_t())) = (aRhs).get_null_t();
            break;
        }
    case TPBlobParent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBlobParent()) PBlobParent*;
            }
            (*(ptr_PBlobParent())) = const_cast<PBlobParent*>((aRhs).get_PBlobParent());
            break;
        }
    case TPBlobChild:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBlobChild()) PBlobChild*;
            }
            (*(ptr_PBlobChild())) = const_cast<PBlobChild*>((aRhs).get_PBlobChild());
            break;
        }
    case TPBackgroundMutableFileParent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*;
            }
            (*(ptr_PBackgroundMutableFileParent())) = const_cast<PBackgroundMutableFileParent*>((aRhs).get_PBackgroundMutableFileParent());
            break;
        }
    case TPBackgroundMutableFileChild:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*;
            }
            (*(ptr_PBackgroundMutableFileChild())) = const_cast<PBackgroundMutableFileChild*>((aRhs).get_PBackgroundMutableFileChild());
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto BlobOrMutableFile::operator==(const null_t& aRhs) const -> bool
{
    return (get_null_t()) == (aRhs);
}

auto BlobOrMutableFile::operator==(PBlobParent* aRhs) const -> bool
{
    return (get_PBlobParent()) == (aRhs);
}

auto BlobOrMutableFile::operator==(PBlobChild* aRhs) const -> bool
{
    return (get_PBlobChild()) == (aRhs);
}

auto BlobOrMutableFile::operator==(PBackgroundMutableFileParent* aRhs) const -> bool
{
    return (get_PBackgroundMutableFileParent()) == (aRhs);
}

auto BlobOrMutableFile::operator==(PBackgroundMutableFileChild* aRhs) const -> bool
{
    return (get_PBackgroundMutableFileChild()) == (aRhs);
}

auto BlobOrMutableFile::operator==(const BlobOrMutableFile& aRhs) const -> bool
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case Tnull_t:
        {
            return (get_null_t()) == ((aRhs).get_null_t());
        }
    case TPBlobParent:
        {
            return (get_PBlobParent()) == ((aRhs).get_PBlobParent());
        }
    case TPBlobChild:
        {
            return (get_PBlobChild()) == ((aRhs).get_PBlobChild());
        }
    case TPBackgroundMutableFileParent:
        {
            return (get_PBackgroundMutableFileParent()) == ((aRhs).get_PBackgroundMutableFileParent());
        }
    case TPBackgroundMutableFileChild:
        {
            return (get_PBackgroundMutableFileChild()) == ((aRhs).get_PBackgroundMutableFileChild());
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return false;
        }
    }
}

auto BlobOrMutableFile::get(null_t* aOutValue) const -> void
{
    (*(aOutValue)) = get_null_t();
}

auto BlobOrMutableFile::get(PBlobParent** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBlobParent();
}

auto BlobOrMutableFile::get(PBlobChild** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBlobChild();
}

auto BlobOrMutableFile::get(PBackgroundMutableFileParent** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBackgroundMutableFileParent();
}

auto BlobOrMutableFile::get(PBackgroundMutableFileChild** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBackgroundMutableFileChild();
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SerializedStructuredCloneFile|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT SerializedStructuredCloneFile::SerializedStructuredCloneFile() :
    type_()
{
    Init();
}

SerializedStructuredCloneFile::~SerializedStructuredCloneFile()
{
}

auto SerializedStructuredCloneFile::operator==(const SerializedStructuredCloneFile& _o) const -> bool
{
    if ((!((file()) == ((_o).file())))) {
        return false;
    }
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    return true;
}

auto SerializedStructuredCloneFile::Init() -> void
{
}

auto SerializedStructuredCloneFile::Assign(
        const BlobOrMutableFile& _file,
        const FileType& _type) -> void
{
    file_ = _file;
    type_ = _type;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SerializedStructuredCloneReadInfo|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT SerializedStructuredCloneReadInfo::SerializedStructuredCloneReadInfo() :
    data_(),
    hasPreprocessInfo_()
{
    Init();
}

SerializedStructuredCloneReadInfo::~SerializedStructuredCloneReadInfo()
{
}

auto SerializedStructuredCloneReadInfo::operator==(const SerializedStructuredCloneReadInfo& _o) const -> bool
{
    if ((!((data()) == ((_o).data())))) {
        return false;
    }
    if ((!((files()) == ((_o).files())))) {
        return false;
    }
    if ((!((hasPreprocessInfo()) == ((_o).hasPreprocessInfo())))) {
        return false;
    }
    return true;
}

auto SerializedStructuredCloneReadInfo::Init() -> void
{
}

auto SerializedStructuredCloneReadInfo::Assign(
        const SerializedStructuredCloneBuffer& _data,
        const nsTArray<SerializedStructuredCloneFile>& _files,
        const bool& _hasPreprocessInfo) -> void
{
    data_ = _data;
    files_ = _files;
    hasPreprocessInfo_ = _hasPreprocessInfo;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct SerializedStructuredCloneWriteInfo|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT SerializedStructuredCloneWriteInfo::SerializedStructuredCloneWriteInfo() :
    data_(),
    offsetToKeyProp_()
{
    Init();
}

SerializedStructuredCloneWriteInfo::~SerializedStructuredCloneWriteInfo()
{
}

auto SerializedStructuredCloneWriteInfo::operator==(const SerializedStructuredCloneWriteInfo& _o) const -> bool
{
    if ((!((data()) == ((_o).data())))) {
        return false;
    }
    if ((!((offsetToKeyProp()) == ((_o).offsetToKeyProp())))) {
        return false;
    }
    return true;
}

auto SerializedStructuredCloneWriteInfo::Init() -> void
{
}

auto SerializedStructuredCloneWriteInfo::Assign(
        const SerializedStructuredCloneBuffer& _data,
        const uint64_t& _offsetToKeyProp) -> void
{
    data_ = _data;
    offsetToKeyProp_ = _offsetToKeyProp;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexUpdateInfo|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexUpdateInfo::IndexUpdateInfo() :
    indexId_(),
    value_(),
    localizedValue_()
{
    Init();
}

IndexUpdateInfo::~IndexUpdateInfo()
{
}

auto IndexUpdateInfo::operator==(const IndexUpdateInfo& _o) const -> bool
{
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((value()) == ((_o).value())))) {
        return false;
    }
    if ((!((localizedValue()) == ((_o).localizedValue())))) {
        return false;
    }
    return true;
}

auto IndexUpdateInfo::Init() -> void
{
}

auto IndexUpdateInfo::Assign(
        const int64_t& _indexId,
        const Key& _value,
        const Key& _localizedValue) -> void
{
    indexId_ = _indexId;
    value_ = _value;
    localizedValue_ = _localizedValue;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OptionalKeyRange|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
auto OptionalKeyRange::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TSerializedKeyRange:
        {
            (ptr_SerializedKeyRange())->~SerializedKeyRange__tdef();
            break;
        }
    case Tvoid_t:
        {
            (ptr_void_t())->~void_t__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT OptionalKeyRange::OptionalKeyRange(const SerializedKeyRange& aOther)
{
    new (mozilla::KnownNotNull, ptr_SerializedKeyRange()) SerializedKeyRange(aOther);
    mType = TSerializedKeyRange;
}

MOZ_IMPLICIT OptionalKeyRange::OptionalKeyRange(const void_t& aOther)
{
    new (mozilla::KnownNotNull, ptr_void_t()) void_t(aOther);
    mType = Tvoid_t;
}

MOZ_IMPLICIT OptionalKeyRange::OptionalKeyRange(const OptionalKeyRange& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TSerializedKeyRange:
        {
            new (mozilla::KnownNotNull, ptr_SerializedKeyRange()) SerializedKeyRange((aOther).get_SerializedKeyRange());
            break;
        }
    case Tvoid_t:
        {
            new (mozilla::KnownNotNull, ptr_void_t()) void_t((aOther).get_void_t());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OptionalKeyRange::~OptionalKeyRange()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto OptionalKeyRange::operator=(const SerializedKeyRange& aRhs) -> OptionalKeyRange&
{
    if (MaybeDestroy(TSerializedKeyRange)) {
        new (mozilla::KnownNotNull, ptr_SerializedKeyRange()) SerializedKeyRange;
    }
    (*(ptr_SerializedKeyRange())) = aRhs;
    mType = TSerializedKeyRange;
    return (*(this));
}

auto OptionalKeyRange::operator=(const void_t& aRhs) -> OptionalKeyRange&
{
    if (MaybeDestroy(Tvoid_t)) {
        new (mozilla::KnownNotNull, ptr_void_t()) void_t;
    }
    (*(ptr_void_t())) = aRhs;
    mType = Tvoid_t;
    return (*(this));
}

auto OptionalKeyRange::operator=(const OptionalKeyRange& aRhs) -> OptionalKeyRange&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TSerializedKeyRange:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_SerializedKeyRange()) SerializedKeyRange;
            }
            (*(ptr_SerializedKeyRange())) = (aRhs).get_SerializedKeyRange();
            break;
        }
    case Tvoid_t:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_void_t()) void_t;
            }
            (*(ptr_void_t())) = (aRhs).get_void_t();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto OptionalKeyRange::operator==(const SerializedKeyRange& aRhs) const -> bool
{
    return (get_SerializedKeyRange()) == (aRhs);
}

auto OptionalKeyRange::operator==(const void_t& aRhs) const -> bool
{
    return (get_void_t()) == (aRhs);
}

auto OptionalKeyRange::operator==(const OptionalKeyRange& aRhs) const -> bool
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TSerializedKeyRange:
        {
            return (get_SerializedKeyRange()) == ((aRhs).get_SerializedKeyRange());
        }
    case Tvoid_t:
        {
            return (get_void_t()) == ((aRhs).get_void_t());
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return false;
        }
    }
}

auto OptionalKeyRange::get(SerializedKeyRange* aOutValue) const -> void
{
    (*(aOutValue)) = get_SerializedKeyRange();
}

auto OptionalKeyRange::get(void_t* aOutValue) const -> void
{
    (*(aOutValue)) = get_void_t();
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DatabaseMetadata|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT DatabaseMetadata::DatabaseMetadata() :
    name_(),
    version_(),
    persistenceType_()
{
    Init();
}

DatabaseMetadata::~DatabaseMetadata()
{
}

auto DatabaseMetadata::operator==(const DatabaseMetadata& _o) const -> bool
{
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((version()) == ((_o).version())))) {
        return false;
    }
    if ((!((persistenceType()) == ((_o).persistenceType())))) {
        return false;
    }
    return true;
}

auto DatabaseMetadata::Init() -> void
{
}

auto DatabaseMetadata::Assign(
        const nsString& _name,
        const uint64_t& _version,
        const PersistenceType& _persistenceType) -> void
{
    name_ = _name;
    version_ = _version;
    persistenceType_ = _persistenceType;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreMetadata|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreMetadata::ObjectStoreMetadata() :
    id_(),
    name_(),
    keyPath_(),
    autoIncrement_()
{
    Init();
}

ObjectStoreMetadata::~ObjectStoreMetadata()
{
}

auto ObjectStoreMetadata::operator==(const ObjectStoreMetadata& _o) const -> bool
{
    if ((!((id()) == ((_o).id())))) {
        return false;
    }
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((keyPath()) == ((_o).keyPath())))) {
        return false;
    }
    if ((!((autoIncrement()) == ((_o).autoIncrement())))) {
        return false;
    }
    return true;
}

auto ObjectStoreMetadata::Init() -> void
{
}

auto ObjectStoreMetadata::Assign(
        const int64_t& _id,
        const nsString& _name,
        const KeyPath& _keyPath,
        const bool& _autoIncrement) -> void
{
    id_ = _id;
    name_ = _name;
    keyPath_ = _keyPath;
    autoIncrement_ = _autoIncrement;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexMetadata|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexMetadata::IndexMetadata() :
    id_(),
    name_(),
    keyPath_(),
    locale_(),
    unique_(),
    multiEntry_(),
    autoLocale_()
{
    Init();
}

IndexMetadata::~IndexMetadata()
{
}

auto IndexMetadata::operator==(const IndexMetadata& _o) const -> bool
{
    if ((!((id()) == ((_o).id())))) {
        return false;
    }
    if ((!((name()) == ((_o).name())))) {
        return false;
    }
    if ((!((keyPath()) == ((_o).keyPath())))) {
        return false;
    }
    if ((!((locale()) == ((_o).locale())))) {
        return false;
    }
    if ((!((unique()) == ((_o).unique())))) {
        return false;
    }
    if ((!((multiEntry()) == ((_o).multiEntry())))) {
        return false;
    }
    if ((!((autoLocale()) == ((_o).autoLocale())))) {
        return false;
    }
    return true;
}

auto IndexMetadata::Init() -> void
{
}

auto IndexMetadata::Assign(
        const int64_t& _id,
        const nsString& _name,
        const KeyPath& _keyPath,
        const nsCString& _locale,
        const bool& _unique,
        const bool& _multiEntry,
        const bool& _autoLocale) -> void
{
    id_ = _id;
    name_ = _name;
    keyPath_ = _keyPath;
    locale_ = _locale;
    unique_ = _unique;
    multiEntry_ = _multiEntry;
    autoLocale_ = _autoLocale;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct DatabaseSpec|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT DatabaseSpec::DatabaseSpec()
{
    Init();
}

DatabaseSpec::~DatabaseSpec()
{
}

auto DatabaseSpec::operator==(const DatabaseSpec& _o) const -> bool
{
    if ((!((metadata()) == ((_o).metadata())))) {
        return false;
    }
    if ((!((objectStores()) == ((_o).objectStores())))) {
        return false;
    }
    return true;
}

auto DatabaseSpec::Init() -> void
{
}

auto DatabaseSpec::Assign(
        const DatabaseMetadata& _metadata,
        const nsTArray<ObjectStoreSpec>& _objectStores) -> void
{
    metadata_ = _metadata;
    objectStores_ = _objectStores;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreSpec|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreSpec::ObjectStoreSpec()
{
    Init();
}

ObjectStoreSpec::~ObjectStoreSpec()
{
}

auto ObjectStoreSpec::operator==(const ObjectStoreSpec& _o) const -> bool
{
    if ((!((metadata()) == ((_o).metadata())))) {
        return false;
    }
    if ((!((indexes()) == ((_o).indexes())))) {
        return false;
    }
    return true;
}

auto ObjectStoreSpec::Init() -> void
{
}

auto ObjectStoreSpec::Assign(
        const ObjectStoreMetadata& _metadata,
        const nsTArray<IndexMetadata>& _indexes) -> void
{
    metadata_ = _metadata;
    indexes_ = _indexes;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreOpenCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreOpenCursorParams::ObjectStoreOpenCursorParams() :
    objectStoreId_(),
    direction_()
{
    Init();
}

ObjectStoreOpenCursorParams::~ObjectStoreOpenCursorParams()
{
}

auto ObjectStoreOpenCursorParams::operator==(const ObjectStoreOpenCursorParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    return true;
}

auto ObjectStoreOpenCursorParams::Init() -> void
{
}

auto ObjectStoreOpenCursorParams::Assign(
        const int64_t& _objectStoreId,
        const OptionalKeyRange& _optionalKeyRange,
        const Direction& _direction) -> void
{
    objectStoreId_ = _objectStoreId;
    optionalKeyRange_ = _optionalKeyRange;
    direction_ = _direction;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreOpenKeyCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreOpenKeyCursorParams::ObjectStoreOpenKeyCursorParams() :
    objectStoreId_(),
    direction_()
{
    Init();
}

ObjectStoreOpenKeyCursorParams::~ObjectStoreOpenKeyCursorParams()
{
}

auto ObjectStoreOpenKeyCursorParams::operator==(const ObjectStoreOpenKeyCursorParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    return true;
}

auto ObjectStoreOpenKeyCursorParams::Init() -> void
{
}

auto ObjectStoreOpenKeyCursorParams::Assign(
        const int64_t& _objectStoreId,
        const OptionalKeyRange& _optionalKeyRange,
        const Direction& _direction) -> void
{
    objectStoreId_ = _objectStoreId;
    optionalKeyRange_ = _optionalKeyRange;
    direction_ = _direction;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexOpenCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexOpenCursorParams::IndexOpenCursorParams() :
    objectStoreId_(),
    indexId_(),
    direction_()
{
    Init();
}

IndexOpenCursorParams::~IndexOpenCursorParams()
{
}

auto IndexOpenCursorParams::operator==(const IndexOpenCursorParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    return true;
}

auto IndexOpenCursorParams::Init() -> void
{
}

auto IndexOpenCursorParams::Assign(
        const int64_t& _objectStoreId,
        const int64_t& _indexId,
        const OptionalKeyRange& _optionalKeyRange,
        const Direction& _direction) -> void
{
    objectStoreId_ = _objectStoreId;
    indexId_ = _indexId;
    optionalKeyRange_ = _optionalKeyRange;
    direction_ = _direction;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexOpenKeyCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexOpenKeyCursorParams::IndexOpenKeyCursorParams() :
    objectStoreId_(),
    indexId_(),
    direction_()
{
    Init();
}

IndexOpenKeyCursorParams::~IndexOpenKeyCursorParams()
{
}

auto IndexOpenKeyCursorParams::operator==(const IndexOpenKeyCursorParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((direction()) == ((_o).direction())))) {
        return false;
    }
    return true;
}

auto IndexOpenKeyCursorParams::Init() -> void
{
}

auto IndexOpenKeyCursorParams::Assign(
        const int64_t& _objectStoreId,
        const int64_t& _indexId,
        const OptionalKeyRange& _optionalKeyRange,
        const Direction& _direction) -> void
{
    objectStoreId_ = _objectStoreId;
    indexId_ = _indexId;
    optionalKeyRange_ = _optionalKeyRange;
    direction_ = _direction;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union OpenCursorParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
auto OpenCursorParams::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TObjectStoreOpenCursorParams:
        {
            (ptr_ObjectStoreOpenCursorParams())->~ObjectStoreOpenCursorParams__tdef();
            break;
        }
    case TObjectStoreOpenKeyCursorParams:
        {
            (ptr_ObjectStoreOpenKeyCursorParams())->~ObjectStoreOpenKeyCursorParams__tdef();
            break;
        }
    case TIndexOpenCursorParams:
        {
            (ptr_IndexOpenCursorParams())->~IndexOpenCursorParams__tdef();
            break;
        }
    case TIndexOpenKeyCursorParams:
        {
            (ptr_IndexOpenKeyCursorParams())->~IndexOpenKeyCursorParams__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT OpenCursorParams::OpenCursorParams(const ObjectStoreOpenCursorParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreOpenCursorParams()) ObjectStoreOpenCursorParams(aOther);
    mType = TObjectStoreOpenCursorParams;
}

MOZ_IMPLICIT OpenCursorParams::OpenCursorParams(const ObjectStoreOpenKeyCursorParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreOpenKeyCursorParams()) ObjectStoreOpenKeyCursorParams(aOther);
    mType = TObjectStoreOpenKeyCursorParams;
}

MOZ_IMPLICIT OpenCursorParams::OpenCursorParams(const IndexOpenCursorParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_IndexOpenCursorParams()) IndexOpenCursorParams(aOther);
    mType = TIndexOpenCursorParams;
}

MOZ_IMPLICIT OpenCursorParams::OpenCursorParams(const IndexOpenKeyCursorParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_IndexOpenKeyCursorParams()) IndexOpenKeyCursorParams(aOther);
    mType = TIndexOpenKeyCursorParams;
}

MOZ_IMPLICIT OpenCursorParams::OpenCursorParams(const OpenCursorParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TObjectStoreOpenCursorParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreOpenCursorParams()) ObjectStoreOpenCursorParams((aOther).get_ObjectStoreOpenCursorParams());
            break;
        }
    case TObjectStoreOpenKeyCursorParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreOpenKeyCursorParams()) ObjectStoreOpenKeyCursorParams((aOther).get_ObjectStoreOpenKeyCursorParams());
            break;
        }
    case TIndexOpenCursorParams:
        {
            new (mozilla::KnownNotNull, ptr_IndexOpenCursorParams()) IndexOpenCursorParams((aOther).get_IndexOpenCursorParams());
            break;
        }
    case TIndexOpenKeyCursorParams:
        {
            new (mozilla::KnownNotNull, ptr_IndexOpenKeyCursorParams()) IndexOpenKeyCursorParams((aOther).get_IndexOpenKeyCursorParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

OpenCursorParams::~OpenCursorParams()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto OpenCursorParams::operator=(const ObjectStoreOpenCursorParams& aRhs) -> OpenCursorParams&
{
    if (MaybeDestroy(TObjectStoreOpenCursorParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreOpenCursorParams()) ObjectStoreOpenCursorParams;
    }
    (*(ptr_ObjectStoreOpenCursorParams())) = aRhs;
    mType = TObjectStoreOpenCursorParams;
    return (*(this));
}

auto OpenCursorParams::operator=(const ObjectStoreOpenKeyCursorParams& aRhs) -> OpenCursorParams&
{
    if (MaybeDestroy(TObjectStoreOpenKeyCursorParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreOpenKeyCursorParams()) ObjectStoreOpenKeyCursorParams;
    }
    (*(ptr_ObjectStoreOpenKeyCursorParams())) = aRhs;
    mType = TObjectStoreOpenKeyCursorParams;
    return (*(this));
}

auto OpenCursorParams::operator=(const IndexOpenCursorParams& aRhs) -> OpenCursorParams&
{
    if (MaybeDestroy(TIndexOpenCursorParams)) {
        new (mozilla::KnownNotNull, ptr_IndexOpenCursorParams()) IndexOpenCursorParams;
    }
    (*(ptr_IndexOpenCursorParams())) = aRhs;
    mType = TIndexOpenCursorParams;
    return (*(this));
}

auto OpenCursorParams::operator=(const IndexOpenKeyCursorParams& aRhs) -> OpenCursorParams&
{
    if (MaybeDestroy(TIndexOpenKeyCursorParams)) {
        new (mozilla::KnownNotNull, ptr_IndexOpenKeyCursorParams()) IndexOpenKeyCursorParams;
    }
    (*(ptr_IndexOpenKeyCursorParams())) = aRhs;
    mType = TIndexOpenKeyCursorParams;
    return (*(this));
}

auto OpenCursorParams::operator=(const OpenCursorParams& aRhs) -> OpenCursorParams&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TObjectStoreOpenCursorParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreOpenCursorParams()) ObjectStoreOpenCursorParams;
            }
            (*(ptr_ObjectStoreOpenCursorParams())) = (aRhs).get_ObjectStoreOpenCursorParams();
            break;
        }
    case TObjectStoreOpenKeyCursorParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreOpenKeyCursorParams()) ObjectStoreOpenKeyCursorParams;
            }
            (*(ptr_ObjectStoreOpenKeyCursorParams())) = (aRhs).get_ObjectStoreOpenKeyCursorParams();
            break;
        }
    case TIndexOpenCursorParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IndexOpenCursorParams()) IndexOpenCursorParams;
            }
            (*(ptr_IndexOpenCursorParams())) = (aRhs).get_IndexOpenCursorParams();
            break;
        }
    case TIndexOpenKeyCursorParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IndexOpenKeyCursorParams()) IndexOpenKeyCursorParams;
            }
            (*(ptr_IndexOpenKeyCursorParams())) = (aRhs).get_IndexOpenKeyCursorParams();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto OpenCursorParams::operator==(const ObjectStoreOpenCursorParams& aRhs) const -> bool
{
    return (get_ObjectStoreOpenCursorParams()) == (aRhs);
}

auto OpenCursorParams::operator==(const ObjectStoreOpenKeyCursorParams& aRhs) const -> bool
{
    return (get_ObjectStoreOpenKeyCursorParams()) == (aRhs);
}

auto OpenCursorParams::operator==(const IndexOpenCursorParams& aRhs) const -> bool
{
    return (get_IndexOpenCursorParams()) == (aRhs);
}

auto OpenCursorParams::operator==(const IndexOpenKeyCursorParams& aRhs) const -> bool
{
    return (get_IndexOpenKeyCursorParams()) == (aRhs);
}

auto OpenCursorParams::operator==(const OpenCursorParams& aRhs) const -> bool
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TObjectStoreOpenCursorParams:
        {
            return (get_ObjectStoreOpenCursorParams()) == ((aRhs).get_ObjectStoreOpenCursorParams());
        }
    case TObjectStoreOpenKeyCursorParams:
        {
            return (get_ObjectStoreOpenKeyCursorParams()) == ((aRhs).get_ObjectStoreOpenKeyCursorParams());
        }
    case TIndexOpenCursorParams:
        {
            return (get_IndexOpenCursorParams()) == ((aRhs).get_IndexOpenCursorParams());
        }
    case TIndexOpenKeyCursorParams:
        {
            return (get_IndexOpenKeyCursorParams()) == ((aRhs).get_IndexOpenKeyCursorParams());
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return false;
        }
    }
}

auto OpenCursorParams::get(ObjectStoreOpenCursorParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreOpenCursorParams();
}

auto OpenCursorParams::get(ObjectStoreOpenKeyCursorParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreOpenKeyCursorParams();
}

auto OpenCursorParams::get(IndexOpenCursorParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_IndexOpenCursorParams();
}

auto OpenCursorParams::get(IndexOpenKeyCursorParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_IndexOpenKeyCursorParams();
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union DatabaseOrMutableFile|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
auto DatabaseOrMutableFile::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TPBackgroundIDBDatabaseFileParent:
        {
            (ptr_PBackgroundIDBDatabaseFileParent())->~PBackgroundIDBDatabaseFileParent__tdef();
            break;
        }
    case TPBackgroundIDBDatabaseFileChild:
        {
            (ptr_PBackgroundIDBDatabaseFileChild())->~PBackgroundIDBDatabaseFileChild__tdef();
            break;
        }
    case TPBackgroundMutableFileParent:
        {
            (ptr_PBackgroundMutableFileParent())->~PBackgroundMutableFileParent__tdef();
            break;
        }
    case TPBackgroundMutableFileChild:
        {
            (ptr_PBackgroundMutableFileChild())->~PBackgroundMutableFileChild__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT DatabaseOrMutableFile::DatabaseOrMutableFile(PBackgroundIDBDatabaseFileParent* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileParent()) PBackgroundIDBDatabaseFileParent*(const_cast<PBackgroundIDBDatabaseFileParent*>(aOther));
    mType = TPBackgroundIDBDatabaseFileParent;
}

MOZ_IMPLICIT DatabaseOrMutableFile::DatabaseOrMutableFile(PBackgroundIDBDatabaseFileChild* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileChild()) PBackgroundIDBDatabaseFileChild*(const_cast<PBackgroundIDBDatabaseFileChild*>(aOther));
    mType = TPBackgroundIDBDatabaseFileChild;
}

MOZ_IMPLICIT DatabaseOrMutableFile::DatabaseOrMutableFile(PBackgroundMutableFileParent* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*(const_cast<PBackgroundMutableFileParent*>(aOther));
    mType = TPBackgroundMutableFileParent;
}

MOZ_IMPLICIT DatabaseOrMutableFile::DatabaseOrMutableFile(PBackgroundMutableFileChild* aOther)
{
    new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*(const_cast<PBackgroundMutableFileChild*>(aOther));
    mType = TPBackgroundMutableFileChild;
}

MOZ_IMPLICIT DatabaseOrMutableFile::DatabaseOrMutableFile(const DatabaseOrMutableFile& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TPBackgroundIDBDatabaseFileParent:
        {
            new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileParent()) PBackgroundIDBDatabaseFileParent*(const_cast<PBackgroundIDBDatabaseFileParent*>((aOther).get_PBackgroundIDBDatabaseFileParent()));
            break;
        }
    case TPBackgroundIDBDatabaseFileChild:
        {
            new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileChild()) PBackgroundIDBDatabaseFileChild*(const_cast<PBackgroundIDBDatabaseFileChild*>((aOther).get_PBackgroundIDBDatabaseFileChild()));
            break;
        }
    case TPBackgroundMutableFileParent:
        {
            new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*(const_cast<PBackgroundMutableFileParent*>((aOther).get_PBackgroundMutableFileParent()));
            break;
        }
    case TPBackgroundMutableFileChild:
        {
            new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*(const_cast<PBackgroundMutableFileChild*>((aOther).get_PBackgroundMutableFileChild()));
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

DatabaseOrMutableFile::~DatabaseOrMutableFile()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto DatabaseOrMutableFile::operator=(PBackgroundIDBDatabaseFileParent* aRhs) -> DatabaseOrMutableFile&
{
    if (MaybeDestroy(TPBackgroundIDBDatabaseFileParent)) {
        new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileParent()) PBackgroundIDBDatabaseFileParent*;
    }
    (*(ptr_PBackgroundIDBDatabaseFileParent())) = const_cast<PBackgroundIDBDatabaseFileParent*>(aRhs);
    mType = TPBackgroundIDBDatabaseFileParent;
    return (*(this));
}

auto DatabaseOrMutableFile::operator=(PBackgroundIDBDatabaseFileChild* aRhs) -> DatabaseOrMutableFile&
{
    if (MaybeDestroy(TPBackgroundIDBDatabaseFileChild)) {
        new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileChild()) PBackgroundIDBDatabaseFileChild*;
    }
    (*(ptr_PBackgroundIDBDatabaseFileChild())) = const_cast<PBackgroundIDBDatabaseFileChild*>(aRhs);
    mType = TPBackgroundIDBDatabaseFileChild;
    return (*(this));
}

auto DatabaseOrMutableFile::operator=(PBackgroundMutableFileParent* aRhs) -> DatabaseOrMutableFile&
{
    if (MaybeDestroy(TPBackgroundMutableFileParent)) {
        new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*;
    }
    (*(ptr_PBackgroundMutableFileParent())) = const_cast<PBackgroundMutableFileParent*>(aRhs);
    mType = TPBackgroundMutableFileParent;
    return (*(this));
}

auto DatabaseOrMutableFile::operator=(PBackgroundMutableFileChild* aRhs) -> DatabaseOrMutableFile&
{
    if (MaybeDestroy(TPBackgroundMutableFileChild)) {
        new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*;
    }
    (*(ptr_PBackgroundMutableFileChild())) = const_cast<PBackgroundMutableFileChild*>(aRhs);
    mType = TPBackgroundMutableFileChild;
    return (*(this));
}

auto DatabaseOrMutableFile::operator=(const DatabaseOrMutableFile& aRhs) -> DatabaseOrMutableFile&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TPBackgroundIDBDatabaseFileParent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileParent()) PBackgroundIDBDatabaseFileParent*;
            }
            (*(ptr_PBackgroundIDBDatabaseFileParent())) = const_cast<PBackgroundIDBDatabaseFileParent*>((aRhs).get_PBackgroundIDBDatabaseFileParent());
            break;
        }
    case TPBackgroundIDBDatabaseFileChild:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBackgroundIDBDatabaseFileChild()) PBackgroundIDBDatabaseFileChild*;
            }
            (*(ptr_PBackgroundIDBDatabaseFileChild())) = const_cast<PBackgroundIDBDatabaseFileChild*>((aRhs).get_PBackgroundIDBDatabaseFileChild());
            break;
        }
    case TPBackgroundMutableFileParent:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileParent()) PBackgroundMutableFileParent*;
            }
            (*(ptr_PBackgroundMutableFileParent())) = const_cast<PBackgroundMutableFileParent*>((aRhs).get_PBackgroundMutableFileParent());
            break;
        }
    case TPBackgroundMutableFileChild:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_PBackgroundMutableFileChild()) PBackgroundMutableFileChild*;
            }
            (*(ptr_PBackgroundMutableFileChild())) = const_cast<PBackgroundMutableFileChild*>((aRhs).get_PBackgroundMutableFileChild());
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto DatabaseOrMutableFile::operator==(PBackgroundIDBDatabaseFileParent* aRhs) const -> bool
{
    return (get_PBackgroundIDBDatabaseFileParent()) == (aRhs);
}

auto DatabaseOrMutableFile::operator==(PBackgroundIDBDatabaseFileChild* aRhs) const -> bool
{
    return (get_PBackgroundIDBDatabaseFileChild()) == (aRhs);
}

auto DatabaseOrMutableFile::operator==(PBackgroundMutableFileParent* aRhs) const -> bool
{
    return (get_PBackgroundMutableFileParent()) == (aRhs);
}

auto DatabaseOrMutableFile::operator==(PBackgroundMutableFileChild* aRhs) const -> bool
{
    return (get_PBackgroundMutableFileChild()) == (aRhs);
}

auto DatabaseOrMutableFile::operator==(const DatabaseOrMutableFile& aRhs) const -> bool
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TPBackgroundIDBDatabaseFileParent:
        {
            return (get_PBackgroundIDBDatabaseFileParent()) == ((aRhs).get_PBackgroundIDBDatabaseFileParent());
        }
    case TPBackgroundIDBDatabaseFileChild:
        {
            return (get_PBackgroundIDBDatabaseFileChild()) == ((aRhs).get_PBackgroundIDBDatabaseFileChild());
        }
    case TPBackgroundMutableFileParent:
        {
            return (get_PBackgroundMutableFileParent()) == ((aRhs).get_PBackgroundMutableFileParent());
        }
    case TPBackgroundMutableFileChild:
        {
            return (get_PBackgroundMutableFileChild()) == ((aRhs).get_PBackgroundMutableFileChild());
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return false;
        }
    }
}

auto DatabaseOrMutableFile::get(PBackgroundIDBDatabaseFileParent** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBackgroundIDBDatabaseFileParent();
}

auto DatabaseOrMutableFile::get(PBackgroundIDBDatabaseFileChild** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBackgroundIDBDatabaseFileChild();
}

auto DatabaseOrMutableFile::get(PBackgroundMutableFileParent** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBackgroundMutableFileParent();
}

auto DatabaseOrMutableFile::get(PBackgroundMutableFileChild** aOutValue) const -> void
{
    (*(aOutValue)) = get_PBackgroundMutableFileChild();
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct FileAddInfo|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT FileAddInfo::FileAddInfo() :
    type_()
{
    Init();
}

FileAddInfo::~FileAddInfo()
{
}

auto FileAddInfo::operator==(const FileAddInfo& _o) const -> bool
{
    if ((!((file()) == ((_o).file())))) {
        return false;
    }
    if ((!((type()) == ((_o).type())))) {
        return false;
    }
    return true;
}

auto FileAddInfo::Init() -> void
{
}

auto FileAddInfo::Assign(
        const DatabaseOrMutableFile& _file,
        const FileType& _type) -> void
{
    file_ = _file;
    type_ = _type;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreAddPutParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreAddPutParams::ObjectStoreAddPutParams() :
    objectStoreId_(),
    key_()
{
    Init();
}

ObjectStoreAddPutParams::~ObjectStoreAddPutParams()
{
}

auto ObjectStoreAddPutParams::operator==(const ObjectStoreAddPutParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((cloneInfo()) == ((_o).cloneInfo())))) {
        return false;
    }
    if ((!((key()) == ((_o).key())))) {
        return false;
    }
    if ((!((indexUpdateInfos()) == ((_o).indexUpdateInfos())))) {
        return false;
    }
    if ((!((fileAddInfos()) == ((_o).fileAddInfos())))) {
        return false;
    }
    return true;
}

auto ObjectStoreAddPutParams::Init() -> void
{
}

auto ObjectStoreAddPutParams::Assign(
        const int64_t& _objectStoreId,
        const SerializedStructuredCloneWriteInfo& _cloneInfo,
        const Key& _key,
        const nsTArray<IndexUpdateInfo>& _indexUpdateInfos,
        const nsTArray<FileAddInfo>& _fileAddInfos) -> void
{
    objectStoreId_ = _objectStoreId;
    cloneInfo_ = _cloneInfo;
    key_ = _key;
    indexUpdateInfos_ = _indexUpdateInfos;
    fileAddInfos_ = _fileAddInfos;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreAddParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreAddParams::ObjectStoreAddParams()
{
    Init();
}

ObjectStoreAddParams::~ObjectStoreAddParams()
{
}

auto ObjectStoreAddParams::operator==(const ObjectStoreAddParams& _o) const -> bool
{
    if ((!((commonParams()) == ((_o).commonParams())))) {
        return false;
    }
    return true;
}

auto ObjectStoreAddParams::Init() -> void
{
}

auto ObjectStoreAddParams::Assign(const ObjectStoreAddPutParams& _commonParams) -> void
{
    commonParams_ = _commonParams;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStorePutParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStorePutParams::ObjectStorePutParams()
{
    Init();
}

ObjectStorePutParams::~ObjectStorePutParams()
{
}

auto ObjectStorePutParams::operator==(const ObjectStorePutParams& _o) const -> bool
{
    if ((!((commonParams()) == ((_o).commonParams())))) {
        return false;
    }
    return true;
}

auto ObjectStorePutParams::Init() -> void
{
}

auto ObjectStorePutParams::Assign(const ObjectStoreAddPutParams& _commonParams) -> void
{
    commonParams_ = _commonParams;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreGetParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreGetParams::ObjectStoreGetParams() :
    objectStoreId_()
{
    Init();
}

ObjectStoreGetParams::~ObjectStoreGetParams()
{
}

auto ObjectStoreGetParams::operator==(const ObjectStoreGetParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

auto ObjectStoreGetParams::Init() -> void
{
}

auto ObjectStoreGetParams::Assign(
        const int64_t& _objectStoreId,
        const SerializedKeyRange& _keyRange) -> void
{
    objectStoreId_ = _objectStoreId;
    keyRange_ = _keyRange;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreGetKeyParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreGetKeyParams::ObjectStoreGetKeyParams() :
    objectStoreId_()
{
    Init();
}

ObjectStoreGetKeyParams::~ObjectStoreGetKeyParams()
{
}

auto ObjectStoreGetKeyParams::operator==(const ObjectStoreGetKeyParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

auto ObjectStoreGetKeyParams::Init() -> void
{
}

auto ObjectStoreGetKeyParams::Assign(
        const int64_t& _objectStoreId,
        const SerializedKeyRange& _keyRange) -> void
{
    objectStoreId_ = _objectStoreId;
    keyRange_ = _keyRange;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreGetAllParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreGetAllParams::ObjectStoreGetAllParams() :
    objectStoreId_(),
    limit_()
{
    Init();
}

ObjectStoreGetAllParams::~ObjectStoreGetAllParams()
{
}

auto ObjectStoreGetAllParams::operator==(const ObjectStoreGetAllParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((limit()) == ((_o).limit())))) {
        return false;
    }
    return true;
}

auto ObjectStoreGetAllParams::Init() -> void
{
}

auto ObjectStoreGetAllParams::Assign(
        const int64_t& _objectStoreId,
        const OptionalKeyRange& _optionalKeyRange,
        const uint32_t& _limit) -> void
{
    objectStoreId_ = _objectStoreId;
    optionalKeyRange_ = _optionalKeyRange;
    limit_ = _limit;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreGetAllKeysParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreGetAllKeysParams::ObjectStoreGetAllKeysParams() :
    objectStoreId_(),
    limit_()
{
    Init();
}

ObjectStoreGetAllKeysParams::~ObjectStoreGetAllKeysParams()
{
}

auto ObjectStoreGetAllKeysParams::operator==(const ObjectStoreGetAllKeysParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((limit()) == ((_o).limit())))) {
        return false;
    }
    return true;
}

auto ObjectStoreGetAllKeysParams::Init() -> void
{
}

auto ObjectStoreGetAllKeysParams::Assign(
        const int64_t& _objectStoreId,
        const OptionalKeyRange& _optionalKeyRange,
        const uint32_t& _limit) -> void
{
    objectStoreId_ = _objectStoreId;
    optionalKeyRange_ = _optionalKeyRange;
    limit_ = _limit;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreDeleteParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreDeleteParams::ObjectStoreDeleteParams() :
    objectStoreId_()
{
    Init();
}

ObjectStoreDeleteParams::~ObjectStoreDeleteParams()
{
}

auto ObjectStoreDeleteParams::operator==(const ObjectStoreDeleteParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

auto ObjectStoreDeleteParams::Init() -> void
{
}

auto ObjectStoreDeleteParams::Assign(
        const int64_t& _objectStoreId,
        const SerializedKeyRange& _keyRange) -> void
{
    objectStoreId_ = _objectStoreId;
    keyRange_ = _keyRange;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreClearParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreClearParams::ObjectStoreClearParams() :
    objectStoreId_()
{
    Init();
}

ObjectStoreClearParams::~ObjectStoreClearParams()
{
}

auto ObjectStoreClearParams::operator==(const ObjectStoreClearParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    return true;
}

auto ObjectStoreClearParams::Init() -> void
{
}

auto ObjectStoreClearParams::Assign(const int64_t& _objectStoreId) -> void
{
    objectStoreId_ = _objectStoreId;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct ObjectStoreCountParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT ObjectStoreCountParams::ObjectStoreCountParams() :
    objectStoreId_()
{
    Init();
}

ObjectStoreCountParams::~ObjectStoreCountParams()
{
}

auto ObjectStoreCountParams::operator==(const ObjectStoreCountParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    return true;
}

auto ObjectStoreCountParams::Init() -> void
{
}

auto ObjectStoreCountParams::Assign(
        const int64_t& _objectStoreId,
        const OptionalKeyRange& _optionalKeyRange) -> void
{
    objectStoreId_ = _objectStoreId;
    optionalKeyRange_ = _optionalKeyRange;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexGetParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexGetParams::IndexGetParams() :
    objectStoreId_(),
    indexId_()
{
    Init();
}

IndexGetParams::~IndexGetParams()
{
}

auto IndexGetParams::operator==(const IndexGetParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

auto IndexGetParams::Init() -> void
{
}

auto IndexGetParams::Assign(
        const int64_t& _objectStoreId,
        const int64_t& _indexId,
        const SerializedKeyRange& _keyRange) -> void
{
    objectStoreId_ = _objectStoreId;
    indexId_ = _indexId;
    keyRange_ = _keyRange;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexGetKeyParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexGetKeyParams::IndexGetKeyParams() :
    objectStoreId_(),
    indexId_()
{
    Init();
}

IndexGetKeyParams::~IndexGetKeyParams()
{
}

auto IndexGetKeyParams::operator==(const IndexGetKeyParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((keyRange()) == ((_o).keyRange())))) {
        return false;
    }
    return true;
}

auto IndexGetKeyParams::Init() -> void
{
}

auto IndexGetKeyParams::Assign(
        const int64_t& _objectStoreId,
        const int64_t& _indexId,
        const SerializedKeyRange& _keyRange) -> void
{
    objectStoreId_ = _objectStoreId;
    indexId_ = _indexId;
    keyRange_ = _keyRange;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexGetAllParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexGetAllParams::IndexGetAllParams() :
    objectStoreId_(),
    indexId_(),
    limit_()
{
    Init();
}

IndexGetAllParams::~IndexGetAllParams()
{
}

auto IndexGetAllParams::operator==(const IndexGetAllParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((limit()) == ((_o).limit())))) {
        return false;
    }
    return true;
}

auto IndexGetAllParams::Init() -> void
{
}

auto IndexGetAllParams::Assign(
        const int64_t& _objectStoreId,
        const int64_t& _indexId,
        const OptionalKeyRange& _optionalKeyRange,
        const uint32_t& _limit) -> void
{
    objectStoreId_ = _objectStoreId;
    indexId_ = _indexId;
    optionalKeyRange_ = _optionalKeyRange;
    limit_ = _limit;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexGetAllKeysParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexGetAllKeysParams::IndexGetAllKeysParams() :
    objectStoreId_(),
    indexId_(),
    limit_()
{
    Init();
}

IndexGetAllKeysParams::~IndexGetAllKeysParams()
{
}

auto IndexGetAllKeysParams::operator==(const IndexGetAllKeysParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    if ((!((limit()) == ((_o).limit())))) {
        return false;
    }
    return true;
}

auto IndexGetAllKeysParams::Init() -> void
{
}

auto IndexGetAllKeysParams::Assign(
        const int64_t& _objectStoreId,
        const int64_t& _indexId,
        const OptionalKeyRange& _optionalKeyRange,
        const uint32_t& _limit) -> void
{
    objectStoreId_ = _objectStoreId;
    indexId_ = _indexId;
    optionalKeyRange_ = _optionalKeyRange;
    limit_ = _limit;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct IndexCountParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT IndexCountParams::IndexCountParams() :
    objectStoreId_(),
    indexId_()
{
    Init();
}

IndexCountParams::~IndexCountParams()
{
}

auto IndexCountParams::operator==(const IndexCountParams& _o) const -> bool
{
    if ((!((objectStoreId()) == ((_o).objectStoreId())))) {
        return false;
    }
    if ((!((indexId()) == ((_o).indexId())))) {
        return false;
    }
    if ((!((optionalKeyRange()) == ((_o).optionalKeyRange())))) {
        return false;
    }
    return true;
}

auto IndexCountParams::Init() -> void
{
}

auto IndexCountParams::Assign(
        const int64_t& _objectStoreId,
        const int64_t& _indexId,
        const OptionalKeyRange& _optionalKeyRange) -> void
{
    objectStoreId_ = _objectStoreId;
    indexId_ = _indexId;
    optionalKeyRange_ = _optionalKeyRange;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |union RequestParams|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
auto RequestParams::MaybeDestroy(Type aNewType) -> bool
{
    if ((mType) == (T__None)) {
        return true;
    }
    if ((mType) == (aNewType)) {
        return false;
    }
    switch (mType) {
    case TObjectStoreAddParams:
        {
            (ptr_ObjectStoreAddParams())->~ObjectStoreAddParams__tdef();
            break;
        }
    case TObjectStorePutParams:
        {
            (ptr_ObjectStorePutParams())->~ObjectStorePutParams__tdef();
            break;
        }
    case TObjectStoreGetParams:
        {
            (ptr_ObjectStoreGetParams())->~ObjectStoreGetParams__tdef();
            break;
        }
    case TObjectStoreGetKeyParams:
        {
            (ptr_ObjectStoreGetKeyParams())->~ObjectStoreGetKeyParams__tdef();
            break;
        }
    case TObjectStoreGetAllParams:
        {
            (ptr_ObjectStoreGetAllParams())->~ObjectStoreGetAllParams__tdef();
            break;
        }
    case TObjectStoreGetAllKeysParams:
        {
            (ptr_ObjectStoreGetAllKeysParams())->~ObjectStoreGetAllKeysParams__tdef();
            break;
        }
    case TObjectStoreDeleteParams:
        {
            (ptr_ObjectStoreDeleteParams())->~ObjectStoreDeleteParams__tdef();
            break;
        }
    case TObjectStoreClearParams:
        {
            (ptr_ObjectStoreClearParams())->~ObjectStoreClearParams__tdef();
            break;
        }
    case TObjectStoreCountParams:
        {
            (ptr_ObjectStoreCountParams())->~ObjectStoreCountParams__tdef();
            break;
        }
    case TIndexGetParams:
        {
            (ptr_IndexGetParams())->~IndexGetParams__tdef();
            break;
        }
    case TIndexGetKeyParams:
        {
            (ptr_IndexGetKeyParams())->~IndexGetKeyParams__tdef();
            break;
        }
    case TIndexGetAllParams:
        {
            (ptr_IndexGetAllParams())->~IndexGetAllParams__tdef();
            break;
        }
    case TIndexGetAllKeysParams:
        {
            (ptr_IndexGetAllKeysParams())->~IndexGetAllKeysParams__tdef();
            break;
        }
    case TIndexCountParams:
        {
            (ptr_IndexCountParams())->~IndexCountParams__tdef();
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("not reached");
            break;
        }
    }
    return true;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreAddParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreAddParams()) ObjectStoreAddParams(aOther);
    mType = TObjectStoreAddParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStorePutParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStorePutParams()) ObjectStorePutParams(aOther);
    mType = TObjectStorePutParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreGetParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreGetParams()) ObjectStoreGetParams(aOther);
    mType = TObjectStoreGetParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreGetKeyParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreGetKeyParams()) ObjectStoreGetKeyParams(aOther);
    mType = TObjectStoreGetKeyParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreGetAllParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllParams()) ObjectStoreGetAllParams(aOther);
    mType = TObjectStoreGetAllParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreGetAllKeysParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllKeysParams()) ObjectStoreGetAllKeysParams(aOther);
    mType = TObjectStoreGetAllKeysParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreDeleteParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreDeleteParams()) ObjectStoreDeleteParams(aOther);
    mType = TObjectStoreDeleteParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreClearParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreClearParams()) ObjectStoreClearParams(aOther);
    mType = TObjectStoreClearParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const ObjectStoreCountParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_ObjectStoreCountParams()) ObjectStoreCountParams(aOther);
    mType = TObjectStoreCountParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const IndexGetParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_IndexGetParams()) IndexGetParams(aOther);
    mType = TIndexGetParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const IndexGetKeyParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_IndexGetKeyParams()) IndexGetKeyParams(aOther);
    mType = TIndexGetKeyParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const IndexGetAllParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_IndexGetAllParams()) IndexGetAllParams(aOther);
    mType = TIndexGetAllParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const IndexGetAllKeysParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_IndexGetAllKeysParams()) IndexGetAllKeysParams(aOther);
    mType = TIndexGetAllKeysParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const IndexCountParams& aOther)
{
    new (mozilla::KnownNotNull, ptr_IndexCountParams()) IndexCountParams(aOther);
    mType = TIndexCountParams;
}

MOZ_IMPLICIT RequestParams::RequestParams(const RequestParams& aOther)
{
    (aOther).AssertSanity();
    switch ((aOther).type()) {
    case TObjectStoreAddParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreAddParams()) ObjectStoreAddParams((aOther).get_ObjectStoreAddParams());
            break;
        }
    case TObjectStorePutParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStorePutParams()) ObjectStorePutParams((aOther).get_ObjectStorePutParams());
            break;
        }
    case TObjectStoreGetParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreGetParams()) ObjectStoreGetParams((aOther).get_ObjectStoreGetParams());
            break;
        }
    case TObjectStoreGetKeyParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreGetKeyParams()) ObjectStoreGetKeyParams((aOther).get_ObjectStoreGetKeyParams());
            break;
        }
    case TObjectStoreGetAllParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllParams()) ObjectStoreGetAllParams((aOther).get_ObjectStoreGetAllParams());
            break;
        }
    case TObjectStoreGetAllKeysParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllKeysParams()) ObjectStoreGetAllKeysParams((aOther).get_ObjectStoreGetAllKeysParams());
            break;
        }
    case TObjectStoreDeleteParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreDeleteParams()) ObjectStoreDeleteParams((aOther).get_ObjectStoreDeleteParams());
            break;
        }
    case TObjectStoreClearParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreClearParams()) ObjectStoreClearParams((aOther).get_ObjectStoreClearParams());
            break;
        }
    case TObjectStoreCountParams:
        {
            new (mozilla::KnownNotNull, ptr_ObjectStoreCountParams()) ObjectStoreCountParams((aOther).get_ObjectStoreCountParams());
            break;
        }
    case TIndexGetParams:
        {
            new (mozilla::KnownNotNull, ptr_IndexGetParams()) IndexGetParams((aOther).get_IndexGetParams());
            break;
        }
    case TIndexGetKeyParams:
        {
            new (mozilla::KnownNotNull, ptr_IndexGetKeyParams()) IndexGetKeyParams((aOther).get_IndexGetKeyParams());
            break;
        }
    case TIndexGetAllParams:
        {
            new (mozilla::KnownNotNull, ptr_IndexGetAllParams()) IndexGetAllParams((aOther).get_IndexGetAllParams());
            break;
        }
    case TIndexGetAllKeysParams:
        {
            new (mozilla::KnownNotNull, ptr_IndexGetAllKeysParams()) IndexGetAllKeysParams((aOther).get_IndexGetAllKeysParams());
            break;
        }
    case TIndexCountParams:
        {
            new (mozilla::KnownNotNull, ptr_IndexCountParams()) IndexCountParams((aOther).get_IndexCountParams());
            break;
        }
    case T__None:
        {
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return;
        }
    }
    mType = (aOther).type();
}

RequestParams::~RequestParams()
{
    static_cast<void>(MaybeDestroy(T__None));
}

auto RequestParams::operator=(const ObjectStoreAddParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreAddParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreAddParams()) ObjectStoreAddParams;
    }
    (*(ptr_ObjectStoreAddParams())) = aRhs;
    mType = TObjectStoreAddParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStorePutParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStorePutParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStorePutParams()) ObjectStorePutParams;
    }
    (*(ptr_ObjectStorePutParams())) = aRhs;
    mType = TObjectStorePutParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStoreGetParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreGetParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreGetParams()) ObjectStoreGetParams;
    }
    (*(ptr_ObjectStoreGetParams())) = aRhs;
    mType = TObjectStoreGetParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStoreGetKeyParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreGetKeyParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreGetKeyParams()) ObjectStoreGetKeyParams;
    }
    (*(ptr_ObjectStoreGetKeyParams())) = aRhs;
    mType = TObjectStoreGetKeyParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStoreGetAllParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreGetAllParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllParams()) ObjectStoreGetAllParams;
    }
    (*(ptr_ObjectStoreGetAllParams())) = aRhs;
    mType = TObjectStoreGetAllParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStoreGetAllKeysParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreGetAllKeysParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllKeysParams()) ObjectStoreGetAllKeysParams;
    }
    (*(ptr_ObjectStoreGetAllKeysParams())) = aRhs;
    mType = TObjectStoreGetAllKeysParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStoreDeleteParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreDeleteParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreDeleteParams()) ObjectStoreDeleteParams;
    }
    (*(ptr_ObjectStoreDeleteParams())) = aRhs;
    mType = TObjectStoreDeleteParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStoreClearParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreClearParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreClearParams()) ObjectStoreClearParams;
    }
    (*(ptr_ObjectStoreClearParams())) = aRhs;
    mType = TObjectStoreClearParams;
    return (*(this));
}

auto RequestParams::operator=(const ObjectStoreCountParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TObjectStoreCountParams)) {
        new (mozilla::KnownNotNull, ptr_ObjectStoreCountParams()) ObjectStoreCountParams;
    }
    (*(ptr_ObjectStoreCountParams())) = aRhs;
    mType = TObjectStoreCountParams;
    return (*(this));
}

auto RequestParams::operator=(const IndexGetParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TIndexGetParams)) {
        new (mozilla::KnownNotNull, ptr_IndexGetParams()) IndexGetParams;
    }
    (*(ptr_IndexGetParams())) = aRhs;
    mType = TIndexGetParams;
    return (*(this));
}

auto RequestParams::operator=(const IndexGetKeyParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TIndexGetKeyParams)) {
        new (mozilla::KnownNotNull, ptr_IndexGetKeyParams()) IndexGetKeyParams;
    }
    (*(ptr_IndexGetKeyParams())) = aRhs;
    mType = TIndexGetKeyParams;
    return (*(this));
}

auto RequestParams::operator=(const IndexGetAllParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TIndexGetAllParams)) {
        new (mozilla::KnownNotNull, ptr_IndexGetAllParams()) IndexGetAllParams;
    }
    (*(ptr_IndexGetAllParams())) = aRhs;
    mType = TIndexGetAllParams;
    return (*(this));
}

auto RequestParams::operator=(const IndexGetAllKeysParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TIndexGetAllKeysParams)) {
        new (mozilla::KnownNotNull, ptr_IndexGetAllKeysParams()) IndexGetAllKeysParams;
    }
    (*(ptr_IndexGetAllKeysParams())) = aRhs;
    mType = TIndexGetAllKeysParams;
    return (*(this));
}

auto RequestParams::operator=(const IndexCountParams& aRhs) -> RequestParams&
{
    if (MaybeDestroy(TIndexCountParams)) {
        new (mozilla::KnownNotNull, ptr_IndexCountParams()) IndexCountParams;
    }
    (*(ptr_IndexCountParams())) = aRhs;
    mType = TIndexCountParams;
    return (*(this));
}

auto RequestParams::operator=(const RequestParams& aRhs) -> RequestParams&
{
    (aRhs).AssertSanity();
    Type t = (aRhs).type();
    switch (t) {
    case TObjectStoreAddParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreAddParams()) ObjectStoreAddParams;
            }
            (*(ptr_ObjectStoreAddParams())) = (aRhs).get_ObjectStoreAddParams();
            break;
        }
    case TObjectStorePutParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStorePutParams()) ObjectStorePutParams;
            }
            (*(ptr_ObjectStorePutParams())) = (aRhs).get_ObjectStorePutParams();
            break;
        }
    case TObjectStoreGetParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreGetParams()) ObjectStoreGetParams;
            }
            (*(ptr_ObjectStoreGetParams())) = (aRhs).get_ObjectStoreGetParams();
            break;
        }
    case TObjectStoreGetKeyParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreGetKeyParams()) ObjectStoreGetKeyParams;
            }
            (*(ptr_ObjectStoreGetKeyParams())) = (aRhs).get_ObjectStoreGetKeyParams();
            break;
        }
    case TObjectStoreGetAllParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllParams()) ObjectStoreGetAllParams;
            }
            (*(ptr_ObjectStoreGetAllParams())) = (aRhs).get_ObjectStoreGetAllParams();
            break;
        }
    case TObjectStoreGetAllKeysParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreGetAllKeysParams()) ObjectStoreGetAllKeysParams;
            }
            (*(ptr_ObjectStoreGetAllKeysParams())) = (aRhs).get_ObjectStoreGetAllKeysParams();
            break;
        }
    case TObjectStoreDeleteParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreDeleteParams()) ObjectStoreDeleteParams;
            }
            (*(ptr_ObjectStoreDeleteParams())) = (aRhs).get_ObjectStoreDeleteParams();
            break;
        }
    case TObjectStoreClearParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreClearParams()) ObjectStoreClearParams;
            }
            (*(ptr_ObjectStoreClearParams())) = (aRhs).get_ObjectStoreClearParams();
            break;
        }
    case TObjectStoreCountParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_ObjectStoreCountParams()) ObjectStoreCountParams;
            }
            (*(ptr_ObjectStoreCountParams())) = (aRhs).get_ObjectStoreCountParams();
            break;
        }
    case TIndexGetParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IndexGetParams()) IndexGetParams;
            }
            (*(ptr_IndexGetParams())) = (aRhs).get_IndexGetParams();
            break;
        }
    case TIndexGetKeyParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IndexGetKeyParams()) IndexGetKeyParams;
            }
            (*(ptr_IndexGetKeyParams())) = (aRhs).get_IndexGetKeyParams();
            break;
        }
    case TIndexGetAllParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IndexGetAllParams()) IndexGetAllParams;
            }
            (*(ptr_IndexGetAllParams())) = (aRhs).get_IndexGetAllParams();
            break;
        }
    case TIndexGetAllKeysParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IndexGetAllKeysParams()) IndexGetAllKeysParams;
            }
            (*(ptr_IndexGetAllKeysParams())) = (aRhs).get_IndexGetAllKeysParams();
            break;
        }
    case TIndexCountParams:
        {
            if (MaybeDestroy(t)) {
                new (mozilla::KnownNotNull, ptr_IndexCountParams()) IndexCountParams;
            }
            (*(ptr_IndexCountParams())) = (aRhs).get_IndexCountParams();
            break;
        }
    case T__None:
        {
            static_cast<void>(MaybeDestroy(t));
            break;
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            break;
        }
    }
    mType = t;
    return (*(this));
}

auto RequestParams::operator==(const ObjectStoreAddParams& aRhs) const -> bool
{
    return (get_ObjectStoreAddParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStorePutParams& aRhs) const -> bool
{
    return (get_ObjectStorePutParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStoreGetParams& aRhs) const -> bool
{
    return (get_ObjectStoreGetParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStoreGetKeyParams& aRhs) const -> bool
{
    return (get_ObjectStoreGetKeyParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStoreGetAllParams& aRhs) const -> bool
{
    return (get_ObjectStoreGetAllParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStoreGetAllKeysParams& aRhs) const -> bool
{
    return (get_ObjectStoreGetAllKeysParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStoreDeleteParams& aRhs) const -> bool
{
    return (get_ObjectStoreDeleteParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStoreClearParams& aRhs) const -> bool
{
    return (get_ObjectStoreClearParams()) == (aRhs);
}

auto RequestParams::operator==(const ObjectStoreCountParams& aRhs) const -> bool
{
    return (get_ObjectStoreCountParams()) == (aRhs);
}

auto RequestParams::operator==(const IndexGetParams& aRhs) const -> bool
{
    return (get_IndexGetParams()) == (aRhs);
}

auto RequestParams::operator==(const IndexGetKeyParams& aRhs) const -> bool
{
    return (get_IndexGetKeyParams()) == (aRhs);
}

auto RequestParams::operator==(const IndexGetAllParams& aRhs) const -> bool
{
    return (get_IndexGetAllParams()) == (aRhs);
}

auto RequestParams::operator==(const IndexGetAllKeysParams& aRhs) const -> bool
{
    return (get_IndexGetAllKeysParams()) == (aRhs);
}

auto RequestParams::operator==(const IndexCountParams& aRhs) const -> bool
{
    return (get_IndexCountParams()) == (aRhs);
}

auto RequestParams::operator==(const RequestParams& aRhs) const -> bool
{
    if ((type()) != ((aRhs).type())) {
        return false;
    }

    switch (type()) {
    case TObjectStoreAddParams:
        {
            return (get_ObjectStoreAddParams()) == ((aRhs).get_ObjectStoreAddParams());
        }
    case TObjectStorePutParams:
        {
            return (get_ObjectStorePutParams()) == ((aRhs).get_ObjectStorePutParams());
        }
    case TObjectStoreGetParams:
        {
            return (get_ObjectStoreGetParams()) == ((aRhs).get_ObjectStoreGetParams());
        }
    case TObjectStoreGetKeyParams:
        {
            return (get_ObjectStoreGetKeyParams()) == ((aRhs).get_ObjectStoreGetKeyParams());
        }
    case TObjectStoreGetAllParams:
        {
            return (get_ObjectStoreGetAllParams()) == ((aRhs).get_ObjectStoreGetAllParams());
        }
    case TObjectStoreGetAllKeysParams:
        {
            return (get_ObjectStoreGetAllKeysParams()) == ((aRhs).get_ObjectStoreGetAllKeysParams());
        }
    case TObjectStoreDeleteParams:
        {
            return (get_ObjectStoreDeleteParams()) == ((aRhs).get_ObjectStoreDeleteParams());
        }
    case TObjectStoreClearParams:
        {
            return (get_ObjectStoreClearParams()) == ((aRhs).get_ObjectStoreClearParams());
        }
    case TObjectStoreCountParams:
        {
            return (get_ObjectStoreCountParams()) == ((aRhs).get_ObjectStoreCountParams());
        }
    case TIndexGetParams:
        {
            return (get_IndexGetParams()) == ((aRhs).get_IndexGetParams());
        }
    case TIndexGetKeyParams:
        {
            return (get_IndexGetKeyParams()) == ((aRhs).get_IndexGetKeyParams());
        }
    case TIndexGetAllParams:
        {
            return (get_IndexGetAllParams()) == ((aRhs).get_IndexGetAllParams());
        }
    case TIndexGetAllKeysParams:
        {
            return (get_IndexGetAllKeysParams()) == ((aRhs).get_IndexGetAllKeysParams());
        }
    case TIndexCountParams:
        {
            return (get_IndexCountParams()) == ((aRhs).get_IndexCountParams());
        }
    default:
        {
            mozilla::ipc::LogicError("unreached");
            return false;
        }
    }
}

auto RequestParams::get(ObjectStoreAddParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreAddParams();
}

auto RequestParams::get(ObjectStorePutParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStorePutParams();
}

auto RequestParams::get(ObjectStoreGetParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreGetParams();
}

auto RequestParams::get(ObjectStoreGetKeyParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreGetKeyParams();
}

auto RequestParams::get(ObjectStoreGetAllParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreGetAllParams();
}

auto RequestParams::get(ObjectStoreGetAllKeysParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreGetAllKeysParams();
}

auto RequestParams::get(ObjectStoreDeleteParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreDeleteParams();
}

auto RequestParams::get(ObjectStoreClearParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreClearParams();
}

auto RequestParams::get(ObjectStoreCountParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_ObjectStoreCountParams();
}

auto RequestParams::get(IndexGetParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_IndexGetParams();
}

auto RequestParams::get(IndexGetKeyParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_IndexGetKeyParams();
}

auto RequestParams::get(IndexGetAllParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_IndexGetAllParams();
}

auto RequestParams::get(IndexGetAllKeysParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_IndexGetAllKeysParams();
}

auto RequestParams::get(IndexCountParams* aOutValue) const -> void
{
    (*(aOutValue)) = get_IndexCountParams();
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla

//-----------------------------------------------------------------------------
// Method definitions for the IPDL type |struct LoggingInfo|
//
namespace mozilla {
namespace dom {
namespace indexedDB {
MOZ_IMPLICIT LoggingInfo::LoggingInfo() :
    backgroundChildLoggingId_(),
    nextTransactionSerialNumber_(),
    nextVersionChangeTransactionSerialNumber_(),
    nextRequestSerialNumber_()
{
    Init();
}

LoggingInfo::~LoggingInfo()
{
}

auto LoggingInfo::operator==(const LoggingInfo& _o) const -> bool
{
    if ((!((backgroundChildLoggingId()) == ((_o).backgroundChildLoggingId())))) {
        return false;
    }
    if ((!((nextTransactionSerialNumber()) == ((_o).nextTransactionSerialNumber())))) {
        return false;
    }
    if ((!((nextVersionChangeTransactionSerialNumber()) == ((_o).nextVersionChangeTransactionSerialNumber())))) {
        return false;
    }
    if ((!((nextRequestSerialNumber()) == ((_o).nextRequestSerialNumber())))) {
        return false;
    }
    return true;
}

auto LoggingInfo::Init() -> void
{
}

auto LoggingInfo::Assign(
        const nsID& _backgroundChildLoggingId,
        const int64_t& _nextTransactionSerialNumber,
        const int64_t& _nextVersionChangeTransactionSerialNumber,
        const uint64_t& _nextRequestSerialNumber) -> void
{
    backgroundChildLoggingId_ = _backgroundChildLoggingId;
    nextTransactionSerialNumber_ = _nextTransactionSerialNumber;
    nextVersionChangeTransactionSerialNumber_ = _nextVersionChangeTransactionSerialNumber;
    nextRequestSerialNumber_ = _nextRequestSerialNumber;
}

} // namespace indexedDB
} // namespace dom
} // namespace mozilla
