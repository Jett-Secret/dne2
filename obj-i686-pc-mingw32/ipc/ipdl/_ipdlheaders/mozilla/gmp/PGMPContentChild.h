//
// Automatically generated by ipdlc.
// Edit at your own risk
//

#ifndef PGMPContentChild_h
#define PGMPContentChild_h

#include "mozilla/gmp/PGMPContent.h"
#ifdef DEBUG
#include "prenv.h"
#endif // DEBUG
#include "base/id_map.h"
#include "mozilla/ipc/MessageChannel.h"

namespace mozilla {
namespace gmp {
class PGMPChild;
} // namespace gmp
} // namespace mozilla
namespace mozilla {
namespace gmp {
class PGMPParent;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPServiceChild;
} // namespace gmp
} // namespace mozilla
namespace mozilla {
namespace gmp {
class PGMPServiceParent;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPVideoDecoderChild;
} // namespace gmp
} // namespace mozilla
namespace mozilla {
namespace gmp {
class PGMPVideoDecoderParent;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPVideoEncoderChild;
} // namespace gmp
} // namespace mozilla
namespace mozilla {
namespace gmp {
class PGMPVideoEncoderParent;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPDecryptorChild;
} // namespace gmp
} // namespace mozilla
namespace mozilla {
namespace gmp {
class PGMPDecryptorParent;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPAudioDecoderChild;
} // namespace gmp
} // namespace mozilla
namespace mozilla {
namespace gmp {
class PGMPAudioDecoderParent;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPVideoEncoderChild;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPAudioDecoderChild;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPVideoDecoderChild;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {
class PGMPDecryptorChild;
} // namespace gmp
} // namespace mozilla

namespace mozilla {
namespace gmp {


class PGMPContentChild :
    public mozilla::ipc::IToplevelProtocol
{
    friend class mozilla::gmp::PGMPVideoEncoderChild;

    friend class mozilla::gmp::PGMPAudioDecoderChild;

    friend class mozilla::gmp::PGMPVideoDecoderChild;

    friend class mozilla::gmp::PGMPDecryptorChild;

protected:
    typedef mozilla::ipc::ActorHandle ActorHandle;
    template<class FooSide> using Endpoint = mozilla::ipc::Endpoint<FooSide>;
    typedef mozilla::ipc::FileDescriptor FileDescriptor;
    typedef base::ProcessId ProcessId;
    typedef mozilla::ipc::ProtocolId ProtocolId;
    typedef mozilla::ipc::Shmem Shmem;
    typedef mozilla::ipc::Transport Transport;
    typedef mozilla::ipc::TransportDescriptor TransportDescriptor;
    typedef mozilla::gmp::PGMPChild PGMPChild;
    typedef mozilla::gmp::PGMPParent PGMPParent;
    typedef mozilla::gmp::PGMPServiceChild PGMPServiceChild;
    typedef mozilla::gmp::PGMPServiceParent PGMPServiceParent;
    typedef mozilla::gmp::PGMPVideoDecoderChild PGMPVideoDecoderChild;
    typedef mozilla::gmp::PGMPVideoDecoderParent PGMPVideoDecoderParent;
    typedef mozilla::gmp::PGMPVideoEncoderChild PGMPVideoEncoderChild;
    typedef mozilla::gmp::PGMPVideoEncoderParent PGMPVideoEncoderParent;
    typedef mozilla::gmp::PGMPDecryptorChild PGMPDecryptorChild;
    typedef mozilla::gmp::PGMPDecryptorParent PGMPDecryptorParent;
    typedef mozilla::gmp::PGMPAudioDecoderChild PGMPAudioDecoderChild;
    typedef mozilla::gmp::PGMPAudioDecoderParent PGMPAudioDecoderParent;

    typedef PGMPContent::State State;

    virtual bool
    RecvPGMPAudioDecoderConstructor(PGMPAudioDecoderChild* actor);
    virtual bool
    RecvPGMPDecryptorConstructor(PGMPDecryptorChild* actor);
    virtual bool
    RecvPGMPVideoDecoderConstructor(
            PGMPVideoDecoderChild* actor,
            const uint32_t& aDecryptorId);
    virtual bool
    RecvPGMPVideoEncoderConstructor(PGMPVideoEncoderChild* actor);
    virtual PGMPAudioDecoderChild*
    AllocPGMPAudioDecoderChild() = 0;
    virtual bool
    DeallocPGMPAudioDecoderChild(PGMPAudioDecoderChild* aActor) = 0;
    virtual PGMPDecryptorChild*
    AllocPGMPDecryptorChild() = 0;
    virtual bool
    DeallocPGMPDecryptorChild(PGMPDecryptorChild* aActor) = 0;
    virtual PGMPVideoDecoderChild*
    AllocPGMPVideoDecoderChild(const uint32_t& aDecryptorId) = 0;
    virtual bool
    DeallocPGMPVideoDecoderChild(PGMPVideoDecoderChild* aActor) = 0;
    virtual PGMPVideoEncoderChild*
    AllocPGMPVideoEncoderChild() = 0;
    virtual bool
    DeallocPGMPVideoEncoderChild(PGMPVideoEncoderChild* aActor) = 0;

    virtual void
    ActorDestroy(ActorDestroyReason aWhy);

    virtual void
    ProcessingError(
            Result aCode,
            const char* aReason);
    virtual bool
    ShouldContinueFromReplyTimeout();
    virtual void
    EnteredCxxStack();
    virtual void
    ExitedCxxStack();
    virtual void
    EnteredCall();
    virtual void
    ExitedCall();

public:
    typedef mozilla::ipc::IProtocol ProtocolBase;
    typedef IPC::Message Message;
    typedef mozilla::ipc::MessageChannel Channel;
    typedef mozilla::ipc::IProtocol ChannelListener;
    typedef base::ProcessHandle ProcessHandle;
    typedef mozilla::ipc::MessageChannel MessageChannel;
    typedef mozilla::ipc::SharedMemory SharedMemory;
    typedef mozilla::ipc::Trigger Trigger;

public:
    MOZ_IMPLICIT PGMPContentChild();

    virtual ~PGMPContentChild();

    void
    ManagedPGMPAudioDecoderChild(nsTArray<PGMPAudioDecoderChild*>& aArr) const;
    const ManagedContainer<PGMPAudioDecoderChild>&
    ManagedPGMPAudioDecoderChild() const;

    void
    ManagedPGMPDecryptorChild(nsTArray<PGMPDecryptorChild*>& aArr) const;
    const ManagedContainer<PGMPDecryptorChild>&
    ManagedPGMPDecryptorChild() const;

    void
    ManagedPGMPVideoDecoderChild(nsTArray<PGMPVideoDecoderChild*>& aArr) const;
    const ManagedContainer<PGMPVideoDecoderChild>&
    ManagedPGMPVideoDecoderChild() const;

    void
    ManagedPGMPVideoEncoderChild(nsTArray<PGMPVideoEncoderChild*>& aArr) const;
    const ManagedContainer<PGMPVideoEncoderChild>&
    ManagedPGMPVideoEncoderChild() const;

    PGMPContent::State
    state();

    virtual MessageChannel*
    GetIPCChannel();
    virtual const MessageChannel*
    GetIPCChannel() const;
    virtual void
    RemoveManagee(
            int32_t aProtocolId,
            ProtocolBase* aListener);

    virtual Result
    OnMessageReceived(const Message& msg__);

    virtual Result
    OnMessageReceived(
            const Message& msg__,
            Message*& reply__);

    virtual Result
    OnCallReceived(
            const Message& msg__,
            Message*& reply__);

    int32_t
    GetProtocolTypeId();

    void
    OnChannelClose();

    void
    OnChannelError();

    void
    ProcessNativeEventsInInterruptCall();

private:
    virtual const char*
    ProtocolName() const;

    void
    DestroySubtree(ActorDestroyReason why);

    void
    DeallocSubtree();

    virtual void
    DeallocPGMPContentChild();

    template<typename T>
    void
    Write(
            const T& v__,
            Message* msg__)
    {
        IPC::WriteParam(msg__, v__);
    }

    template<typename T>
    bool
    Read(
            T* v__,
            const Message* msg__,
            PickleIterator* iter__)
    {
        return IPC::ReadParam(msg__, iter__, v__);
    }

    void
    Write(
            const PGMPVideoEncoderChild* v__,
            Message* msg__,
            bool nullable__);

    MOZ_MUST_USE bool
    Read(
            PGMPVideoEncoderChild** v__,
            const Message* msg__,
            PickleIterator* iter__,
            bool nullable__);

    void
    Write(
            const PGMPAudioDecoderChild* v__,
            Message* msg__,
            bool nullable__);

    MOZ_MUST_USE bool
    Read(
            PGMPAudioDecoderChild** v__,
            const Message* msg__,
            PickleIterator* iter__,
            bool nullable__);

    void
    Write(
            const PGMPVideoDecoderChild* v__,
            Message* msg__,
            bool nullable__);

    MOZ_MUST_USE bool
    Read(
            PGMPVideoDecoderChild** v__,
            const Message* msg__,
            PickleIterator* iter__,
            bool nullable__);

    void
    Write(
            const PGMPDecryptorChild* v__,
            Message* msg__,
            bool nullable__);

    MOZ_MUST_USE bool
    Read(
            PGMPDecryptorChild** v__,
            const Message* msg__,
            PickleIterator* iter__,
            bool nullable__);

    Channel mChannel;
    State mState;
    ManagedContainer<PGMPAudioDecoderChild> mManagedPGMPAudioDecoderChild;
    ManagedContainer<PGMPDecryptorChild> mManagedPGMPDecryptorChild;
    ManagedContainer<PGMPVideoDecoderChild> mManagedPGMPVideoDecoderChild;
    ManagedContainer<PGMPVideoEncoderChild> mManagedPGMPVideoEncoderChild;
};


} // namespace gmp
} // namespace mozilla

#if 0

//-----------------------------------------------------------------------------
// Skeleton implementation of abstract actor class

// Header file contents
namespace mozilla {
namespace gmp {
class GMPContentChild :
    public PGMPContentChild
{
    virtual PGMPAudioDecoderChild*
    AllocPGMPAudioDecoderChild();

    virtual bool
    DeallocPGMPAudioDecoderChild(PGMPAudioDecoderChild* aActor);

    virtual PGMPDecryptorChild*
    AllocPGMPDecryptorChild();

    virtual bool
    DeallocPGMPDecryptorChild(PGMPDecryptorChild* aActor);

    virtual PGMPVideoDecoderChild*
    AllocPGMPVideoDecoderChild(const uint32_t& aDecryptorId);

    virtual bool
    DeallocPGMPVideoDecoderChild(PGMPVideoDecoderChild* aActor);

    virtual PGMPVideoEncoderChild*
    AllocPGMPVideoEncoderChild();

    virtual bool
    DeallocPGMPVideoEncoderChild(PGMPVideoEncoderChild* aActor);

    MOZ_IMPLICIT GMPContentChild();
    virtual ~GMPContentChild();
};
} // namespace gmp
} // namespace mozilla


// C++ file contents
namespace mozilla {
namespace gmp {
PGMPAudioDecoderChild*
GMPContentChild::AllocPGMPAudioDecoderChild()
{
    return 0;
}

bool
GMPContentChild::DeallocPGMPAudioDecoderChild(PGMPAudioDecoderChild* aActor)
{
    return false;
}

PGMPDecryptorChild*
GMPContentChild::AllocPGMPDecryptorChild()
{
    return 0;
}

bool
GMPContentChild::DeallocPGMPDecryptorChild(PGMPDecryptorChild* aActor)
{
    return false;
}

PGMPVideoDecoderChild*
GMPContentChild::AllocPGMPVideoDecoderChild(const uint32_t& aDecryptorId)
{
    return 0;
}

bool
GMPContentChild::DeallocPGMPVideoDecoderChild(PGMPVideoDecoderChild* aActor)
{
    return false;
}

PGMPVideoEncoderChild*
GMPContentChild::AllocPGMPVideoEncoderChild()
{
    return 0;
}

bool
GMPContentChild::DeallocPGMPVideoEncoderChild(PGMPVideoEncoderChild* aActor)
{
    return false;
}

MOZ_IMPLICIT GMPContentChild::GMPContentChild()
{
    MOZ_COUNT_CTOR(GMPContentChild);
}

MOZ_IMPLICIT GMPContentChild::~GMPContentChild()
{
    MOZ_COUNT_DTOR(GMPContentChild);
}

} // namespace gmp
} // namespace mozilla
#endif // if 0

#endif // ifndef PGMPContentChild_h
