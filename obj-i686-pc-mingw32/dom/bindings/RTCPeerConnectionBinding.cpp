/* THIS FILE IS AUTOGENERATED FROM RTCPeerConnection.webidl BY Codegen.py - DO NOT EDIT */

#include "AtomList.h"
#include "DOMMediaStream.h"
#include "EventHandlerBinding.h"
#include "EventTargetBinding.h"
#include "RTCConfigurationBinding.h"
#include "RTCIceCandidateBinding.h"
#include "RTCPeerConnectionBinding.h"
#include "RTCRtpReceiverBinding.h"
#include "RTCRtpSenderBinding.h"
#include "RTCSessionDescriptionBinding.h"
#include "RTCStatsReportBinding.h"
#include "SubtleCryptoBinding.h"
#include "WrapperFactory.h"
#include "jsapi.h"
#include "mozilla/OwningNonNull.h"
#include "mozilla/Preferences.h"
#include "mozilla/dom/BindingUtils.h"
#include "mozilla/dom/DOMError.h"
#include "mozilla/dom/DOMJSClass.h"
#include "mozilla/dom/MediaStreamTrack.h"
#include "mozilla/dom/NonRefcountedDOMObject.h"
#include "mozilla/dom/Nullable.h"
#include "mozilla/dom/PrimitiveConversions.h"
#include "mozilla/dom/Promise.h"
#include "mozilla/dom/RTCCertificate.h"
#include "mozilla/dom/ScriptSettings.h"
#include "mozilla/dom/SimpleGlobalObject.h"
#include "mozilla/dom/ToJSValue.h"
#include "mozilla/dom/UnionConversions.h"
#include "mozilla/dom/XrayExpandoClass.h"
#include "nsContentUtils.h"
#include "nsIDOMDataChannel.h"
#include "nsIDocument.h"
#include "nsIGlobalObject.h"

namespace mozilla {
namespace dom {

namespace RTCSignalingStateValues {
extern const EnumEntry strings[7] = {
  {"stable", 6},
  {"have-local-offer", 16},
  {"have-remote-offer", 17},
  {"have-local-pranswer", 19},
  {"have-remote-pranswer", 20},
  {"closed", 6},
  { nullptr, 0 }
};
} // namespace RTCSignalingStateValues

bool
ToJSValue(JSContext* aCx, RTCSignalingState aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(RTCSignalingStateValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, RTCSignalingStateValues::strings[uint32_t(aArgument)].value,
                      RTCSignalingStateValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


namespace RTCIceGatheringStateValues {
extern const EnumEntry strings[4] = {
  {"new", 3},
  {"gathering", 9},
  {"complete", 8},
  { nullptr, 0 }
};
} // namespace RTCIceGatheringStateValues

bool
ToJSValue(JSContext* aCx, RTCIceGatheringState aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(RTCIceGatheringStateValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, RTCIceGatheringStateValues::strings[uint32_t(aArgument)].value,
                      RTCIceGatheringStateValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}


namespace RTCIceConnectionStateValues {
extern const EnumEntry strings[8] = {
  {"new", 3},
  {"checking", 8},
  {"connected", 9},
  {"completed", 9},
  {"failed", 6},
  {"disconnected", 12},
  {"closed", 6},
  { nullptr, 0 }
};
} // namespace RTCIceConnectionStateValues

bool
ToJSValue(JSContext* aCx, RTCIceConnectionState aArgument, JS::MutableHandle<JS::Value> aValue)
{
  MOZ_ASSERT(uint32_t(aArgument) < ArrayLength(RTCIceConnectionStateValues::strings));
  JSString* resultStr =
    JS_NewStringCopyN(aCx, RTCIceConnectionStateValues::strings[uint32_t(aArgument)].value,
                      RTCIceConnectionStateValues::strings[uint32_t(aArgument)].length);
  if (!resultStr) {
    return false;
  }
  aValue.setString(resultStr);
  return true;
}



DeprecatedRTCOfferOptionsSet::DeprecatedRTCOfferOptionsSet()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
DeprecatedRTCOfferOptionsSet::InitIds(JSContext* cx, DeprecatedRTCOfferOptionsSetAtoms* atomsCache)
{
  MOZ_ASSERT(!*reinterpret_cast<jsid**>(atomsCache));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->OfferToReceiveVideo_id.init(cx, "OfferToReceiveVideo") ||
      !atomsCache->OfferToReceiveAudio_id.init(cx, "OfferToReceiveAudio") ||
      !atomsCache->MozDontOfferDataChannel_id.init(cx, "MozDontOfferDataChannel") ||
      !atomsCache->MozBundleOnly_id.init(cx, "MozBundleOnly")) {
    return false;
  }
  return true;
}

bool
DeprecatedRTCOfferOptionsSet::Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  DeprecatedRTCOfferOptionsSetAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<DeprecatedRTCOfferOptionsSetAtoms>(cx);
    if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  { // scope for isConvertible
    bool isConvertible;
    if (!IsConvertibleToDictionary(cx, val, &isConvertible)) {
      return false;
    }
    if (!isConvertible) {
      return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY, sourceDescription);
    }
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->MozBundleOnly_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mMozBundleOnly.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mMozBundleOnly.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->MozDontOfferDataChannel_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mMozDontOfferDataChannel.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mMozDontOfferDataChannel.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->OfferToReceiveAudio_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOfferToReceiveAudio.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mOfferToReceiveAudio.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->OfferToReceiveVideo_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOfferToReceiveVideo.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mOfferToReceiveVideo.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
DeprecatedRTCOfferOptionsSet::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
DeprecatedRTCOfferOptionsSet::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  DeprecatedRTCOfferOptionsSetAtoms* atomsCache = GetAtomCache<DeprecatedRTCOfferOptionsSetAtoms>(cx);
  if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  if (mMozBundleOnly.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mMozBundleOnly.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->MozBundleOnly_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mMozDontOfferDataChannel.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mMozDontOfferDataChannel.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->MozDontOfferDataChannel_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mOfferToReceiveAudio.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mOfferToReceiveAudio.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->OfferToReceiveAudio_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mOfferToReceiveVideo.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mOfferToReceiveVideo.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->OfferToReceiveVideo_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  return true;
}

bool
DeprecatedRTCOfferOptionsSet::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSAutoCompartment ac(cx, binding_detail::UnprivilegedJunkScopeOrWorkerGlobal());
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
DeprecatedRTCOfferOptionsSet::TraceDictionary(JSTracer* trc)
{
}

void
DeprecatedRTCOfferOptionsSet::operator=(const DeprecatedRTCOfferOptionsSet& aOther)
{
  mMozBundleOnly.Reset();
  if (aOther.mMozBundleOnly.WasPassed()) {
    mMozBundleOnly.Construct(aOther.mMozBundleOnly.Value());
  }
  mMozDontOfferDataChannel.Reset();
  if (aOther.mMozDontOfferDataChannel.WasPassed()) {
    mMozDontOfferDataChannel.Construct(aOther.mMozDontOfferDataChannel.Value());
  }
  mOfferToReceiveAudio.Reset();
  if (aOther.mOfferToReceiveAudio.WasPassed()) {
    mOfferToReceiveAudio.Construct(aOther.mOfferToReceiveAudio.Value());
  }
  mOfferToReceiveVideo.Reset();
  if (aOther.mOfferToReceiveVideo.WasPassed()) {
    mOfferToReceiveVideo.Construct(aOther.mOfferToReceiveVideo.Value());
  }
}

namespace binding_detail {
} // namespace binding_detail



RTCDataChannelInit::RTCDataChannelInit()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
RTCDataChannelInit::InitIds(JSContext* cx, RTCDataChannelInitAtoms* atomsCache)
{
  MOZ_ASSERT(!*reinterpret_cast<jsid**>(atomsCache));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->stream_id.init(cx, "stream") ||
      !atomsCache->protocol_id.init(cx, "protocol") ||
      !atomsCache->preset_id.init(cx, "preset") ||
      !atomsCache->outOfOrderAllowed_id.init(cx, "outOfOrderAllowed") ||
      !atomsCache->ordered_id.init(cx, "ordered") ||
      !atomsCache->negotiated_id.init(cx, "negotiated") ||
      !atomsCache->maxRetransmits_id.init(cx, "maxRetransmits") ||
      !atomsCache->maxRetransmitTime_id.init(cx, "maxRetransmitTime") ||
      !atomsCache->maxRetransmitNum_id.init(cx, "maxRetransmitNum") ||
      !atomsCache->id_id.init(cx, "id")) {
    return false;
  }
  return true;
}

bool
RTCDataChannelInit::Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  RTCDataChannelInitAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<RTCDataChannelInitAtoms>(cx);
    if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  { // scope for isConvertible
    bool isConvertible;
    if (!IsConvertibleToDictionary(cx, val, &isConvertible)) {
      return false;
    }
    if (!isConvertible) {
      return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY, sourceDescription);
    }
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->id_id, temp.ptr())) {
      return false;
    }
  }
  if (!(!isNull && !temp->isUndefined()) || temp.ref().isNullOrUndefined()) {
    mId.SetNull();
  } else if (!ValueToPrimitive<uint16_t, eDefault>(cx, temp.ref(), &mId.SetValue())) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->maxRetransmitNum_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mMaxRetransmitNum.Construct();
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, temp.ref(), &(mMaxRetransmitNum.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->maxRetransmitTime_id, temp.ptr())) {
      return false;
    }
  }
  if (!(!isNull && !temp->isUndefined()) || temp.ref().isNullOrUndefined()) {
    mMaxRetransmitTime.SetNull();
  } else if (!ValueToPrimitive<uint16_t, eDefault>(cx, temp.ref(), &mMaxRetransmitTime.SetValue())) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->maxRetransmits_id, temp.ptr())) {
      return false;
    }
  }
  if (!(!isNull && !temp->isUndefined()) || temp.ref().isNullOrUndefined()) {
    mMaxRetransmits.SetNull();
  } else if (!ValueToPrimitive<uint16_t, eDefault>(cx, temp.ref(), &mMaxRetransmits.SetValue())) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->negotiated_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &mNegotiated)) {
      return false;
    }
  } else {
    mNegotiated = false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->ordered_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &mOrdered)) {
      return false;
    }
  } else {
    mOrdered = true;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->outOfOrderAllowed_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOutOfOrderAllowed.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mOutOfOrderAllowed.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->preset_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mPreset.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mPreset.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->protocol_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ConvertJSValueToString(cx, temp.ref(), eStringify, eStringify, mProtocol)) {
      return false;
    }
  } else {
    static const char16_t data[] = { 0 };
    mProtocol.Rebind(data, ArrayLength(data) - 1);
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->stream_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mStream.Construct();
    if (!ValueToPrimitive<uint16_t, eDefault>(cx, temp.ref(), &(mStream.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
RTCDataChannelInit::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
RTCDataChannelInit::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  RTCDataChannelInitAtoms* atomsCache = GetAtomCache<RTCDataChannelInitAtoms>(cx);
  if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
    return false;
  }

  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<uint16_t> const & currentValue = mId;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->id_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    temp.setInt32(int32_t(currentValue.Value()));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->id_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  if (mMaxRetransmitNum.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint16_t const & currentValue = mMaxRetransmitNum.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->maxRetransmitNum_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<uint16_t> const & currentValue = mMaxRetransmitTime;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->maxRetransmitTime_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    temp.setInt32(int32_t(currentValue.Value()));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->maxRetransmitTime_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    Nullable<uint16_t> const & currentValue = mMaxRetransmits;
    if (currentValue.IsNull()) {
      temp.setNull();
      if (!JS_DefinePropertyById(cx, obj, atomsCache->maxRetransmits_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    }
    temp.setInt32(int32_t(currentValue.Value()));
    if (!JS_DefinePropertyById(cx, obj, atomsCache->maxRetransmits_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mNegotiated;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->negotiated_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mOrdered;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->ordered_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  if (mOutOfOrderAllowed.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mOutOfOrderAllowed.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->outOfOrderAllowed_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mPreset.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mPreset.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->preset_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    nsString const & currentValue = mProtocol;
    if (!xpc::NonVoidStringToJsval(cx, currentValue, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->protocol_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  if (mStream.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      uint16_t const & currentValue = mStream.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->stream_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  return true;
}

bool
RTCDataChannelInit::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSAutoCompartment ac(cx, binding_detail::UnprivilegedJunkScopeOrWorkerGlobal());
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
RTCDataChannelInit::TraceDictionary(JSTracer* trc)
{
}

void
RTCDataChannelInit::operator=(const RTCDataChannelInit& aOther)
{
  mId = aOther.mId;
  mMaxRetransmitNum.Reset();
  if (aOther.mMaxRetransmitNum.WasPassed()) {
    mMaxRetransmitNum.Construct(aOther.mMaxRetransmitNum.Value());
  }
  mMaxRetransmitTime = aOther.mMaxRetransmitTime;
  mMaxRetransmits = aOther.mMaxRetransmits;
  mNegotiated = aOther.mNegotiated;
  mOrdered = aOther.mOrdered;
  mOutOfOrderAllowed.Reset();
  if (aOther.mOutOfOrderAllowed.WasPassed()) {
    mOutOfOrderAllowed.Construct(aOther.mOutOfOrderAllowed.Value());
  }
  mPreset.Reset();
  if (aOther.mPreset.WasPassed()) {
    mPreset.Construct(aOther.mPreset.Value());
  }
  mProtocol = aOther.mProtocol;
  mStream.Reset();
  if (aOther.mStream.WasPassed()) {
    mStream.Construct(aOther.mStream.Value());
  }
}

namespace binding_detail {
} // namespace binding_detail



RTCOfferAnswerOptions::RTCOfferAnswerOptions()
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
RTCOfferAnswerOptions::Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  { // scope for isConvertible
    bool isConvertible;
    if (!IsConvertibleToDictionary(cx, val, &isConvertible)) {
      return false;
    }
    if (!isConvertible) {
      return ThrowErrorMessage(cx, MSG_NOT_DICTIONARY, sourceDescription);
    }
  }

  return true;
}

bool
RTCOfferAnswerOptions::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
RTCOfferAnswerOptions::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  JS::Rooted<JSObject*> obj(cx, JS_NewPlainObject(cx));
  if (!obj) {
    return false;
  }
  rval.set(JS::ObjectValue(*obj));


  return true;
}

bool
RTCOfferAnswerOptions::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSAutoCompartment ac(cx, binding_detail::UnprivilegedJunkScopeOrWorkerGlobal());
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
RTCOfferAnswerOptions::TraceDictionary(JSTracer* trc)
{
}

void
RTCOfferAnswerOptions::operator=(const RTCOfferAnswerOptions& aOther)
{
}

namespace binding_detail {
} // namespace binding_detail



RTCAnswerOptions::RTCAnswerOptions()
  : RTCOfferAnswerOptions(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
RTCAnswerOptions::Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  // Per spec, we init the parent's members first
  if (!RTCOfferAnswerOptions::Init(cx, val)) {
    return false;
  }

  return true;
}

bool
RTCAnswerOptions::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
RTCAnswerOptions::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  // Per spec, we define the parent's members first
  if (!RTCOfferAnswerOptions::ToObjectInternal(cx, rval)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &rval.toObject());


  return true;
}

bool
RTCAnswerOptions::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSAutoCompartment ac(cx, binding_detail::UnprivilegedJunkScopeOrWorkerGlobal());
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
RTCAnswerOptions::TraceDictionary(JSTracer* trc)
{
  RTCOfferAnswerOptions::TraceDictionary(trc);
}

void
RTCAnswerOptions::operator=(const RTCAnswerOptions& aOther)
{
  RTCOfferAnswerOptions::operator=(aOther);
}

namespace binding_detail {
} // namespace binding_detail



RTCOfferOptions::RTCOfferOptions()
  : RTCOfferAnswerOptions(FastDictionaryInitializer()),
    mMandatory(FastDictionaryInitializer())
{
  // Safe to pass a null context if we pass a null value
  Init(nullptr, JS::NullHandleValue);
}



bool
RTCOfferOptions::InitIds(JSContext* cx, RTCOfferOptionsAtoms* atomsCache)
{
  MOZ_ASSERT(!*reinterpret_cast<jsid**>(atomsCache));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->optional_id.init(cx, "optional") ||
      !atomsCache->offerToReceiveVideo_id.init(cx, "offerToReceiveVideo") ||
      !atomsCache->offerToReceiveAudio_id.init(cx, "offerToReceiveAudio") ||
      !atomsCache->mozDontOfferDataChannel_id.init(cx, "mozDontOfferDataChannel") ||
      !atomsCache->mozBundleOnly_id.init(cx, "mozBundleOnly") ||
      !atomsCache->mandatory_id.init(cx, "mandatory") ||
      !atomsCache->iceRestart_id.init(cx, "iceRestart")) {
    return false;
  }
  return true;
}

bool
RTCOfferOptions::Init(JSContext* cx, JS::Handle<JS::Value> val, const char* sourceDescription, bool passedToJSImpl)
{
  // Passing a null JSContext is OK only if we're initing from null,
  // Since in that case we will not have to do any property gets
  MOZ_ASSERT_IF(!cx, val.isNull());
  RTCOfferOptionsAtoms* atomsCache = nullptr;
  if (cx) {
    atomsCache = GetAtomCache<RTCOfferOptionsAtoms>(cx);
    if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
      return false;
    }
  }

  // Per spec, we init the parent's members first
  if (!RTCOfferAnswerOptions::Init(cx, val)) {
    return false;
  }

  bool isNull = val.isNullOrUndefined();
  // We only need these if !isNull, in which case we have |cx|.
  Maybe<JS::Rooted<JSObject *> > object;
  Maybe<JS::Rooted<JS::Value> > temp;
  if (!isNull) {
    MOZ_ASSERT(cx);
    object.emplace(cx, &val.toObject());
    temp.emplace(cx);
  }
  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->iceRestart_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &mIceRestart)) {
      return false;
    }
  } else {
    mIceRestart = false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->mandatory_id, temp.ptr())) {
      return false;
    }
  }
  if (!mMandatory.Init(cx, (!isNull && !temp->isUndefined()) ? temp.ref() : JS::NullHandleValue,  "'mandatory' member of RTCOfferOptions", passedToJSImpl)) {
    return false;
  }
  mIsAnyMemberPresent = true;

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->mozBundleOnly_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mMozBundleOnly.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mMozBundleOnly.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->mozDontOfferDataChannel_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mMozDontOfferDataChannel.Construct();
    if (!ValueToPrimitive<bool, eDefault>(cx, temp.ref(), &(mMozDontOfferDataChannel.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->offerToReceiveAudio_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOfferToReceiveAudio.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), &(mOfferToReceiveAudio.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->offerToReceiveVideo_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOfferToReceiveVideo.Construct();
    if (!ValueToPrimitive<int32_t, eDefault>(cx, temp.ref(), &(mOfferToReceiveVideo.Value()))) {
      return false;
    }
    mIsAnyMemberPresent = true;
  }

  if (!isNull) {
    if (!JS_GetPropertyById(cx, *object, atomsCache->optional_id, temp.ptr())) {
      return false;
    }
  }
  if (!isNull && !temp->isUndefined()) {
    mOptional.Construct();
    if (temp.ref().isObject()) {
      JS::ForOfIterator iter(cx);
      if (!iter.init(temp.ref(), JS::ForOfIterator::AllowNonIterable)) {
        return false;
      }
      if (!iter.valueIsIterable()) {
        ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "'optional' member of RTCOfferOptions");
        return false;
      }
      Sequence<DeprecatedRTCOfferOptionsSet> &arr = (mOptional.Value());
      JS::Rooted<JS::Value> temp(cx);
      while (true) {
        bool done;
        if (!iter.next(&temp, &done)) {
          return false;
        }
        if (done) {
          break;
        }
        DeprecatedRTCOfferOptionsSet* slotPtr = arr.AppendElement(mozilla::fallible);
        if (!slotPtr) {
          JS_ReportOutOfMemory(cx);
          return false;
        }
        DeprecatedRTCOfferOptionsSet& slot = *slotPtr;
        if (!slot.Init(cx, temp,  "Element of 'optional' member of RTCOfferOptions", passedToJSImpl)) {
          return false;
        }
      }
    } else {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "'optional' member of RTCOfferOptions");
      return false;
    }
    mIsAnyMemberPresent = true;
  }
  return true;
}

bool
RTCOfferOptions::Init(const nsAString& aJSON)
{
  AutoJSAPI jsapi;
  JSObject* cleanGlobal = SimpleGlobalObject::Create(SimpleGlobalObject::GlobalType::BindingDetail);
  if (!cleanGlobal) {
    return false;
  }
  if (!jsapi.Init(cleanGlobal)) {
    return false;
  }
  JSContext* cx = jsapi.cx();
  JS::Rooted<JS::Value> json(cx);
  bool ok = ParseJSON(cx, aJSON, &json);
  NS_ENSURE_TRUE(ok, false);
  return Init(cx, json);
}

bool
RTCOfferOptions::ToObjectInternal(JSContext* cx, JS::MutableHandle<JS::Value> rval) const
{
  RTCOfferOptionsAtoms* atomsCache = GetAtomCache<RTCOfferOptionsAtoms>(cx);
  if (!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) {
    return false;
  }

  // Per spec, we define the parent's members first
  if (!RTCOfferAnswerOptions::ToObjectInternal(cx, rval)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &rval.toObject());

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    bool const & currentValue = mIceRestart;
    temp.setBoolean(currentValue);
    if (!JS_DefinePropertyById(cx, obj, atomsCache->iceRestart_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  do {
    // block for our 'break' successCode and scope for 'temp' and 'currentValue'
    JS::Rooted<JS::Value> temp(cx);
    DeprecatedRTCOfferOptionsSet const & currentValue = mMandatory;
    if (!currentValue.ToObjectInternal(cx, &temp)) {
      return false;
    }
    if (!JS_DefinePropertyById(cx, obj, atomsCache->mandatory_id, temp, JSPROP_ENUMERATE)) {
      return false;
    }
    break;
  } while(0);

  if (mMozBundleOnly.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mMozBundleOnly.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->mozBundleOnly_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mMozDontOfferDataChannel.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      bool const & currentValue = mMozDontOfferDataChannel.InternalValue();
      temp.setBoolean(currentValue);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->mozDontOfferDataChannel_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mOfferToReceiveAudio.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mOfferToReceiveAudio.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->offerToReceiveAudio_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mOfferToReceiveVideo.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      int32_t const & currentValue = mOfferToReceiveVideo.InternalValue();
      temp.setInt32(int32_t(currentValue));
      if (!JS_DefinePropertyById(cx, obj, atomsCache->offerToReceiveVideo_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  if (mOptional.WasPassed()) {
    do {
      // block for our 'break' successCode and scope for 'temp' and 'currentValue'
      JS::Rooted<JS::Value> temp(cx);
      Sequence<DeprecatedRTCOfferOptionsSet> const & currentValue = mOptional.InternalValue();

      uint32_t length = currentValue.Length();
      JS::Rooted<JSObject*> returnArray(cx, JS_NewArrayObject(cx, length));
      if (!returnArray) {
        return false;
      }
      // Scope for 'tmp'
      {
        JS::Rooted<JS::Value> tmp(cx);
        for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
          // Control block to let us common up the JS_DefineElement calls when there
          // are different ways to succeed at wrapping the object.
          do {
            if (!currentValue[sequenceIdx0].ToObjectInternal(cx, &tmp)) {
              return false;
            }
            break;
          } while (0);
          if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                                JSPROP_ENUMERATE)) {
            return false;
          }
        }
      }
      temp.setObject(*returnArray);
      if (!JS_DefinePropertyById(cx, obj, atomsCache->optional_id, temp, JSPROP_ENUMERATE)) {
        return false;
      }
      break;
    } while(0);
  }

  return true;
}

bool
RTCOfferOptions::ToJSON(nsAString& aJSON) const
{
  AutoJSAPI jsapi;
  jsapi.Init();
  JSContext *cx = jsapi.cx();
  // It's safe to use UnprivilegedJunkScopeOrWorkerGlobal here
  // because we'll only be creating objects, in ways that have no
  // side-effects, followed by a call to JS::ToJSONMaybeSafely,
  // which likewise guarantees no side-effects for the sorts of
  // things we will pass it.
  JSAutoCompartment ac(cx, binding_detail::UnprivilegedJunkScopeOrWorkerGlobal());
  JS::Rooted<JS::Value> val(cx);
  if (!ToObjectInternal(cx, &val)) {
    return false;
  }
  JS::Rooted<JSObject*> obj(cx, &val.toObject());
  return StringifyToJSON(cx, obj, aJSON);
}

void
RTCOfferOptions::TraceDictionary(JSTracer* trc)
{
  RTCOfferAnswerOptions::TraceDictionary(trc);
}

void
RTCOfferOptions::operator=(const RTCOfferOptions& aOther)
{
  RTCOfferAnswerOptions::operator=(aOther);
  mIceRestart = aOther.mIceRestart;
  mMandatory = aOther.mMandatory;
  mMozBundleOnly.Reset();
  if (aOther.mMozBundleOnly.WasPassed()) {
    mMozBundleOnly.Construct(aOther.mMozBundleOnly.Value());
  }
  mMozDontOfferDataChannel.Reset();
  if (aOther.mMozDontOfferDataChannel.WasPassed()) {
    mMozDontOfferDataChannel.Construct(aOther.mMozDontOfferDataChannel.Value());
  }
  mOfferToReceiveAudio.Reset();
  if (aOther.mOfferToReceiveAudio.WasPassed()) {
    mOfferToReceiveAudio.Construct(aOther.mOfferToReceiveAudio.Value());
  }
  mOfferToReceiveVideo.Reset();
  if (aOther.mOfferToReceiveVideo.WasPassed()) {
    mOfferToReceiveVideo.Construct(aOther.mOfferToReceiveVideo.Value());
  }
  mOptional.Reset();
  if (aOther.mOptional.WasPassed()) {
    mOptional.Construct(aOther.mOptional.Value());
  }
}

namespace binding_detail {
} // namespace binding_detail


void
RTCSessionDescriptionCallback::Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, RTCSessionDescription& sdp, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, sdp, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



void
RTCPeerConnectionErrorCallback::Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, DOMError& error, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, error, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



void
VoidFunction::Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



void
RTCStatsCallback::Call(JSContext* cx, JS::Handle<JS::Value> aThisVal, RTCStatsReport& report, ErrorResult& aRv)
{
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, report, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, aThisVal, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}



namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace binding_detail {
} // namespace binding_detail


namespace RTCPeerConnectionBinding {

static_assert(IsRefcounted<NativeType>::value == IsRefcounted<EventTargetBinding::NativeType>::value,
              "Can't inherit from an interface with a different ownership model.");

static bool
generateCertificate(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());

  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.generateCertificate");
  }
  GlobalObject global(cx, xpc::XrayAwareCalleeGlobal(obj));
  if (global.Failed()) {
    return false;
  }

  ObjectOrString arg0;
  ObjectOrStringArgument arg0_holder(arg0);
  {
    bool done = false, failed = false, tryNext;
    if (args[0].isObject()) {
      if (!arg0_holder.SetToObject(cx, &args[0].toObject(), true)) {
        return false;
      }
      done = true;
    } else {
      do {
        done = (failed = !arg0_holder.TrySetToString(cx, args[0], tryNext)) || !tryNext;
        break;
      } while (0);
    }
    if (failed) {
      return false;
    }
    if (!done) {
      ThrowErrorMessage(cx, MSG_NOT_IN_UNION, "Argument 1 of RTCPeerConnection.generateCertificate", "Object");
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(mozilla::dom::RTCCertificate::GenerateCertificate(global, Constify(arg0), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}


static const JSJitInfo generateCertificate_methodinfo = {
  { (JSJitGetterOp)generateCertificate },
  { prototypes::id::_ID_Count }, { 0 }, JSJitInfo::StaticMethod,
  JSJitInfo::AliasEverything, JSVAL_TYPE_MISSING, false, false,
  false, false, 0
};

static bool
setIdentityProvider(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.setIdentityProvider");
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  Optional<nsAString> arg1;
  binding_detail::FakeString arg1_holder;
  if (args.hasDefined(1)) {
    if (!ConvertJSValueToString(cx, args[1], eStringify, eStringify, arg1_holder)) {
      return false;
    }
    arg1 = &arg1_holder;
  }
  Optional<nsAString> arg2;
  binding_detail::FakeString arg2_holder;
  if (args.hasDefined(2)) {
    if (!ConvertJSValueToString(cx, args[2], eStringify, eStringify, arg2_holder)) {
      return false;
    }
    arg2 = &arg2_holder;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetIdentityProvider(NonNullHelper(Constify(arg0)), NonNullHelper(Constify(arg1)), NonNullHelper(Constify(arg2)), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo setIdentityProvider_methodinfo = {
  { (JSJitGetterOp)setIdentityProvider },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getIdentityAssertion(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(self->GetIdentityAssertion(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
getIdentityAssertion_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = getIdentityAssertion(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo getIdentityAssertion_methodinfo = {
  { (JSJitGetterOp)getIdentityAssertion_promiseWrapper },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
createOffer(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 0: {
      MOZ_FALLTHROUGH;
    }
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FastRTCOfferOptions arg0;
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue,  "Argument 1 of RTCPeerConnection.createOffer", true)) {
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->CreateOffer(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    case 2: {
      MOZ_FALLTHROUGH;
    }
    case 3: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCSessionDescriptionCallback>> arg0(cx);
      if (args[0].isObject()) {
        if (JS::IsCallable(&args[0].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
            arg0 = new binding_detail::FastRTCSessionDescriptionCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 1 of RTCPeerConnection.createOffer");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.createOffer");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCPeerConnectionErrorCallback>> arg1(cx);
      if (args[1].isObject()) {
        if (JS::IsCallable(&args[1].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[1].toObject());
            arg1 = new binding_detail::FastRTCPeerConnectionErrorCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 2 of RTCPeerConnection.createOffer");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.createOffer");
        return false;
      }
      binding_detail::FastRTCOfferOptions arg2;
      if (!arg2.Init(cx, (args.hasDefined(2)) ? args[2] : JS::NullHandleValue,  "Argument 3 of RTCPeerConnection.createOffer", true)) {
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->CreateOffer(NonNullHelper(arg0), NonNullHelper(arg1), Constify(arg2), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.createOffer");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
createOffer_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = createOffer(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo createOffer_methodinfo = {
  { (JSJitGetterOp)createOffer_promiseWrapper },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
createAnswer(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 2u);
  switch (argcount) {
    case 0: {
      MOZ_FALLTHROUGH;
    }
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      binding_detail::FastRTCAnswerOptions arg0;
      if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue,  "Argument 1 of RTCPeerConnection.createAnswer", true)) {
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->CreateAnswer(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    case 2: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCSessionDescriptionCallback>> arg0(cx);
      if (args[0].isObject()) {
        if (JS::IsCallable(&args[0].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
            arg0 = new binding_detail::FastRTCSessionDescriptionCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 1 of RTCPeerConnection.createAnswer");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.createAnswer");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCPeerConnectionErrorCallback>> arg1(cx);
      if (args[1].isObject()) {
        if (JS::IsCallable(&args[1].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[1].toObject());
            arg1 = new binding_detail::FastRTCPeerConnectionErrorCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 2 of RTCPeerConnection.createAnswer");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.createAnswer");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->CreateAnswer(NonNullHelper(arg0), NonNullHelper(arg1), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.createAnswer");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
createAnswer_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = createAnswer(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo createAnswer_methodinfo = {
  { (JSJitGetterOp)createAnswer_promiseWrapper },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
setLocalDescription(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      NonNull<mozilla::dom::RTCSessionDescription> arg0;
      if (args[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::RTCSessionDescription, mozilla::dom::RTCSessionDescription>(args[0], arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.setLocalDescription", "RTCSessionDescription");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.setLocalDescription");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->SetLocalDescription(NonNullHelper(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    case 3: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      NonNull<mozilla::dom::RTCSessionDescription> arg0;
      if (args[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::RTCSessionDescription, mozilla::dom::RTCSessionDescription>(args[0], arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.setLocalDescription", "RTCSessionDescription");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.setLocalDescription");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastVoidFunction>> arg1(cx);
      if (args[1].isObject()) {
        if (JS::IsCallable(&args[1].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[1].toObject());
            arg1 = new binding_detail::FastVoidFunction(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 2 of RTCPeerConnection.setLocalDescription");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.setLocalDescription");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCPeerConnectionErrorCallback>> arg2(cx);
      if (args[2].isObject()) {
        if (JS::IsCallable(&args[2].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[2].toObject());
            arg2 = new binding_detail::FastRTCPeerConnectionErrorCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 3 of RTCPeerConnection.setLocalDescription");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 3 of RTCPeerConnection.setLocalDescription");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->SetLocalDescription(NonNullHelper(arg0), NonNullHelper(arg1), NonNullHelper(arg2), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.setLocalDescription");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
setLocalDescription_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = setLocalDescription(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo setLocalDescription_methodinfo = {
  { (JSJitGetterOp)setLocalDescription_promiseWrapper },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
setRemoteDescription(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      NonNull<mozilla::dom::RTCSessionDescription> arg0;
      if (args[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::RTCSessionDescription, mozilla::dom::RTCSessionDescription>(args[0], arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.setRemoteDescription", "RTCSessionDescription");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.setRemoteDescription");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->SetRemoteDescription(NonNullHelper(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    case 3: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      NonNull<mozilla::dom::RTCSessionDescription> arg0;
      if (args[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::RTCSessionDescription, mozilla::dom::RTCSessionDescription>(args[0], arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.setRemoteDescription", "RTCSessionDescription");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.setRemoteDescription");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastVoidFunction>> arg1(cx);
      if (args[1].isObject()) {
        if (JS::IsCallable(&args[1].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[1].toObject());
            arg1 = new binding_detail::FastVoidFunction(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 2 of RTCPeerConnection.setRemoteDescription");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.setRemoteDescription");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCPeerConnectionErrorCallback>> arg2(cx);
      if (args[2].isObject()) {
        if (JS::IsCallable(&args[2].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[2].toObject());
            arg2 = new binding_detail::FastRTCPeerConnectionErrorCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 3 of RTCPeerConnection.setRemoteDescription");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 3 of RTCPeerConnection.setRemoteDescription");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->SetRemoteDescription(NonNullHelper(arg0), NonNullHelper(arg1), NonNullHelper(arg2), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.setRemoteDescription");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
setRemoteDescription_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = setRemoteDescription(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo setRemoteDescription_methodinfo = {
  { (JSJitGetterOp)setRemoteDescription_promiseWrapper },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_localDescription(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::RTCSessionDescription>(self->GetLocalDescription(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo localDescription_getterinfo = {
  { (JSJitGetterOp)get_localDescription },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_remoteDescription(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::RTCSessionDescription>(self->GetRemoteDescription(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo remoteDescription_getterinfo = {
  { (JSJitGetterOp)get_remoteDescription },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_signalingState(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RTCSignalingState result(self->GetSignalingState(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo signalingState_getterinfo = {
  { (JSJitGetterOp)get_signalingState },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
addIceCandidate(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      NonNull<mozilla::dom::RTCIceCandidate> arg0;
      if (args[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::RTCIceCandidate, mozilla::dom::RTCIceCandidate>(args[0], arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.addIceCandidate", "RTCIceCandidate");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.addIceCandidate");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->AddIceCandidate(NonNullHelper(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    case 3: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      NonNull<mozilla::dom::RTCIceCandidate> arg0;
      if (args[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::RTCIceCandidate, mozilla::dom::RTCIceCandidate>(args[0], arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.addIceCandidate", "RTCIceCandidate");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.addIceCandidate");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastVoidFunction>> arg1(cx);
      if (args[1].isObject()) {
        if (JS::IsCallable(&args[1].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[1].toObject());
            arg1 = new binding_detail::FastVoidFunction(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 2 of RTCPeerConnection.addIceCandidate");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.addIceCandidate");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCPeerConnectionErrorCallback>> arg2(cx);
      if (args[2].isObject()) {
        if (JS::IsCallable(&args[2].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[2].toObject());
            arg2 = new binding_detail::FastRTCPeerConnectionErrorCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 3 of RTCPeerConnection.addIceCandidate");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 3 of RTCPeerConnection.addIceCandidate");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->AddIceCandidate(NonNullHelper(arg0), NonNullHelper(arg1), NonNullHelper(arg2), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.addIceCandidate");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
addIceCandidate_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = addIceCandidate(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo addIceCandidate_methodinfo = {
  { (JSJitGetterOp)addIceCandidate_promiseWrapper },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_canTrickleIceCandidates(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  Nullable<bool> result(self->GetCanTrickleIceCandidates(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result.IsNull()) {
    args.rval().setNull();
    return true;
  }
  args.rval().setBoolean(result.Value());
  return true;
}

static const JSJitInfo canTrickleIceCandidates_getterinfo = {
  { (JSJitGetterOp)get_canTrickleIceCandidates },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_iceGatheringState(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RTCIceGatheringState result(self->GetIceGatheringState(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo iceGatheringState_getterinfo = {
  { (JSJitGetterOp)get_iceGatheringState },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_iceConnectionState(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RTCIceConnectionState result(self->GetIceConnectionState(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo iceConnectionState_getterinfo = {
  { (JSJitGetterOp)get_iceConnectionState },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_peerIdentity(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<Promise>(self->GetPeerIdentity(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!ToJSValue(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo peerIdentity_getterinfo = {
  { (JSJitGetterOp)get_peerIdentity },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_idpLoginUrl(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  DOMString result;
  self->GetIdpLoginUrl(result, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::StringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo idpLoginUrl_getterinfo = {
  { (JSJitGetterOp)get_idpLoginUrl },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_id(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  DOMString result;
  self->GetId(result, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!xpc::NonVoidStringToJsval(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static bool
set_id(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetId(NonNullHelper(Constify(arg0)), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo id_getterinfo = {
  { (JSJitGetterOp)get_id },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_STRING,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo id_setterinfo = {
  { (JSJitGetterOp)set_id },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getConfiguration(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RTCConfiguration result;
  self->GetConfiguration(result, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result.ToObjectInternal(cx, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo getConfiguration_methodinfo = {
  { (JSJitGetterOp)getConfiguration },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getLocalStreams(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  DeprecationWarning(cx, obj, nsIDocument::eRTCPeerConnectionGetStreams);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::DOMMediaStream>::Type> result;
  self->GetLocalStreams(result, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS_NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(true || JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo getLocalStreams_methodinfo = {
  { (JSJitGetterOp)getLocalStreams },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getRemoteStreams(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  DeprecationWarning(cx, obj, nsIDocument::eRTCPeerConnectionGetStreams);
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::DOMMediaStream>::Type> result;
  self->GetRemoteStreams(result, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS_NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(true || JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo getRemoteStreams_methodinfo = {
  { (JSJitGetterOp)getRemoteStreams },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getStreamById(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.getStreamById");
  }
  if (!mozilla::dom::EnforceNotInPrerendering(cx, obj)) {
      // Return false from the JSNative in order to trigger
      // an uncatchable exception.
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      return false;
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::DOMMediaStream>(self->GetStreamById(NonNullHelper(Constify(arg0)), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!result) {
    args.rval().setNull();
    return true;
  }
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo getStreamById_methodinfo = {
  { (JSJitGetterOp)getStreamById },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
addStream(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.addStream");
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::DOMMediaStream> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::MediaStream, mozilla::DOMMediaStream>(args[0], arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.addStream", "MediaStream");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.addStream");
    return false;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->AddStream(NonNullHelper(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo addStream_methodinfo = {
  { (JSJitGetterOp)addStream },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
addTrack(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.addTrack");
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::MediaStreamTrack> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::MediaStreamTrack, mozilla::dom::MediaStreamTrack>(args[0], arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.addTrack", "MediaStreamTrack");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.addTrack");
    return false;
  }
  NonNull<mozilla::DOMMediaStream> arg1;
  if (args[1].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::MediaStream, mozilla::DOMMediaStream>(args[1], arg1);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 2 of RTCPeerConnection.addTrack", "MediaStream");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.addTrack");
    return false;
  }
  binding_detail::AutoSequence<OwningNonNull<mozilla::DOMMediaStream>> arg2;
  if (args.length() > 2) {
    if (!arg2.SetCapacity(args.length() - 2, mozilla::fallible)) {
      JS_ReportOutOfMemory(cx);
      return false;
    }
    for (uint32_t variadicArg = 2; variadicArg < args.length(); ++variadicArg) {
      OwningNonNull<mozilla::DOMMediaStream>& slot = *arg2.AppendElement(mozilla::fallible);
      if (args[variadicArg].isObject()) {
        static_assert(IsRefcounted<mozilla::DOMMediaStream>::value, "We can only store refcounted classes.");{
          nsresult rv = UnwrapObject<prototypes::id::MediaStream, mozilla::DOMMediaStream>(args[variadicArg], slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 3 of RTCPeerConnection.addTrack", "MediaStream");
            return false;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 3 of RTCPeerConnection.addTrack");
        return false;
      }
    }
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::RTCRtpSender>(self->AddTrack(NonNullHelper(arg0), NonNullHelper(arg1), NonNullHelper(Constify(arg2)), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!GetOrCreateDOMReflector(cx, result, args.rval())) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const JSJitInfo addTrack_methodinfo = {
  { (JSJitGetterOp)addTrack },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
removeTrack(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.removeTrack");
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::RTCRtpSender> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::RTCRtpSender, mozilla::dom::RTCRtpSender>(args[0], arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.removeTrack", "RTCRtpSender");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.removeTrack");
    return false;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->RemoveTrack(NonNullHelper(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo removeTrack_methodinfo = {
  { (JSJitGetterOp)removeTrack },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getSenders(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::RTCRtpSender>::Type> result;
  self->GetSenders(result, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS_NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(true || JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo getSenders_methodinfo = {
  { (JSJitGetterOp)getSenders },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getReceivers(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  nsTArray<StrongPtrForMember<mozilla::dom::RTCRtpReceiver>::Type> result;
  self->GetReceivers(result, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  uint32_t length = result.Length();
  JS::Rooted<JSObject*> returnArray(cx, JS_NewArrayObject(cx, length));
  if (!returnArray) {
    return false;
  }
  // Scope for 'tmp'
  {
    JS::Rooted<JS::Value> tmp(cx);
    for (uint32_t sequenceIdx0 = 0; sequenceIdx0 < length; ++sequenceIdx0) {
      // Control block to let us common up the JS_DefineElement calls when there
      // are different ways to succeed at wrapping the object.
      do {
        if (!GetOrCreateDOMReflector(cx, result[sequenceIdx0], &tmp)) {
          MOZ_ASSERT(true || JS_IsExceptionPending(cx));
          return false;
        }
        break;
      } while (0);
      if (!JS_DefineElement(cx, returnArray, sequenceIdx0, tmp,
                            JSPROP_ENUMERATE)) {
        return false;
      }
    }
  }
  args.rval().setObject(*returnArray);
  return true;
}

static const JSJitInfo getReceivers_methodinfo = {
  { (JSJitGetterOp)getReceivers },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
mozSelectSsrc(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 2)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.mozSelectSsrc");
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  NonNull<mozilla::dom::RTCRtpReceiver> arg0;
  if (args[0].isObject()) {
    {
      nsresult rv = UnwrapObject<prototypes::id::RTCRtpReceiver, mozilla::dom::RTCRtpReceiver>(args[0], arg0);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.mozSelectSsrc", "RTCRtpReceiver");
        return false;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.mozSelectSsrc");
    return false;
  }
  uint16_t arg1;
  if (!ValueToPrimitive<uint16_t, eDefault>(cx, args[1], &arg1)) {
    return false;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->MozSelectSsrc(NonNullHelper(arg0), arg1, rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo mozSelectSsrc_methodinfo = {
  { (JSJitGetterOp)mozSelectSsrc },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
close(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->Close(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  args.rval().setUndefined();
  return true;
}

static const JSJitInfo close_methodinfo = {
  { (JSJitGetterOp)close },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_onnegotiationneeded(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOnnegotiationneeded(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onnegotiationneeded(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOnnegotiationneeded(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onnegotiationneeded_getterinfo = {
  { (JSJitGetterOp)get_onnegotiationneeded },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo onnegotiationneeded_setterinfo = {
  { (JSJitGetterOp)set_onnegotiationneeded },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_onicecandidate(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOnicecandidate(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onicecandidate(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOnicecandidate(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onicecandidate_getterinfo = {
  { (JSJitGetterOp)get_onicecandidate },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo onicecandidate_setterinfo = {
  { (JSJitGetterOp)set_onicecandidate },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_onsignalingstatechange(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOnsignalingstatechange(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onsignalingstatechange(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOnsignalingstatechange(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onsignalingstatechange_getterinfo = {
  { (JSJitGetterOp)get_onsignalingstatechange },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo onsignalingstatechange_setterinfo = {
  { (JSJitGetterOp)set_onsignalingstatechange },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_onaddstream(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOnaddstream(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onaddstream(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOnaddstream(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onaddstream_getterinfo = {
  { (JSJitGetterOp)get_onaddstream },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo onaddstream_setterinfo = {
  { (JSJitGetterOp)set_onaddstream },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_onaddtrack(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOnaddtrack(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onaddtrack(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOnaddtrack(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onaddtrack_getterinfo = {
  { (JSJitGetterOp)get_onaddtrack },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo onaddtrack_setterinfo = {
  { (JSJitGetterOp)set_onaddtrack },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_ontrack(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOntrack(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ontrack(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOntrack(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ontrack_getterinfo = {
  { (JSJitGetterOp)get_ontrack },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo ontrack_setterinfo = {
  { (JSJitGetterOp)set_ontrack },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_onremovestream(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOnremovestream(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_onremovestream(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOnremovestream(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo onremovestream_getterinfo = {
  { (JSJitGetterOp)get_onremovestream },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo onremovestream_setterinfo = {
  { (JSJitGetterOp)set_onremovestream },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_oniceconnectionstatechange(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOniceconnectionstatechange(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_oniceconnectionstatechange(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOniceconnectionstatechange(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo oniceconnectionstatechange_getterinfo = {
  { (JSJitGetterOp)get_oniceconnectionstatechange },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo oniceconnectionstatechange_setterinfo = {
  { (JSJitGetterOp)set_oniceconnectionstatechange },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
getStats(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  unsigned argcount = std::min(args.length(), 3u);
  switch (argcount) {
    case 0: {
      MOZ_FALLTHROUGH;
    }
    case 1: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      Optional<mozilla::dom::MediaStreamTrack*> arg0;
      if (args.hasDefined(0)) {
        arg0.Construct();
        if (args[0].isObject()) {
          {
            nsresult rv = UnwrapObject<prototypes::id::MediaStreamTrack, mozilla::dom::MediaStreamTrack>(args[0], arg0.Value());
            if (NS_FAILED(rv)) {
              ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.getStats", "MediaStreamTrack");
              return false;
            }
          }
        } else if (args[0].isNullOrUndefined()) {
          arg0.Value() = nullptr;
        } else {
          ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.getStats");
          return false;
        }
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->GetStats(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    case 3: {
      Maybe<JS::Rooted<JSObject*> > unwrappedObj;
      bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
      if (objIsXray) {
        unwrappedObj.emplace(cx, obj);
      }
      mozilla::dom::MediaStreamTrack* arg0;
      if (args[0].isObject()) {
        {
          nsresult rv = UnwrapObject<prototypes::id::MediaStreamTrack, mozilla::dom::MediaStreamTrack>(args[0], arg0);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Argument 1 of RTCPeerConnection.getStats", "MediaStreamTrack");
            return false;
          }
        }
      } else if (args[0].isNullOrUndefined()) {
        arg0 = nullptr;
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection.getStats");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCStatsCallback>> arg1(cx);
      if (args[1].isObject()) {
        if (JS::IsCallable(&args[1].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[1].toObject());
            arg1 = new binding_detail::FastRTCStatsCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 2 of RTCPeerConnection.getStats");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.getStats");
        return false;
      }
      RootedCallback<OwningNonNull<binding_detail::FastRTCPeerConnectionErrorCallback>> arg2(cx);
      if (args[2].isObject()) {
        if (JS::IsCallable(&args[2].toObject())) {
          { // Scope for tempRoot
            JS::Rooted<JSObject*> tempRoot(cx, &args[2].toObject());
            arg2 = new binding_detail::FastRTCPeerConnectionErrorCallback(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
          }
        } else {
          ThrowErrorMessage(cx, MSG_NOT_CALLABLE, "Argument 3 of RTCPeerConnection.getStats");
          return false;
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 3 of RTCPeerConnection.getStats");
        return false;
      }
      if (objIsXray) {
        unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
        if (!unwrappedObj.ref()) {
          return false;
        }
      }
      binding_detail::FastErrorResult rv;
      auto result(StrongOrRawPtr<Promise>(self->GetStats(Constify(arg0), NonNullHelper(arg1), NonNullHelper(arg2), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
      if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
        return false;
      }
      MOZ_ASSERT(!JS_IsExceptionPending(cx));
      if (!ToJSValue(cx, result, args.rval())) {
        return false;
      }
      return true;
      break;
    }
    default: {
      return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.getStats");
      break;
    }
  }
  MOZ_CRASH("We have an always-returning default case");
  return false;
}

static bool
getStats_promiseWrapper(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  // Make sure to save the callee before someone maybe messes
  // with rval().
  JS::Rooted<JSObject*> callee(cx, &args.callee());
  bool ok = getStats(cx, obj, self, args);
  if (ok) {
    return true;
  }
  return ConvertExceptionToPromise(cx, xpc::XrayAwareCalleeGlobal(callee),
                                   args.rval());
}

static const JSJitInfo getStats_methodinfo = {
  { (JSJitGetterOp)getStats_promiseWrapper },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
createDataChannel(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, const JSJitMethodCallArgs& args)
{
  if (MOZ_UNLIKELY(args.length() < 1)) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection.createDataChannel");
  }
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  binding_detail::FakeString arg0;
  if (!ConvertJSValueToString(cx, args[0], eStringify, eStringify, arg0)) {
    return false;
  }
  binding_detail::FastRTCDataChannelInit arg1;
  if (!arg1.Init(cx, (args.hasDefined(1)) ? args[1] : JS::NullHandleValue,  "Argument 2 of RTCPeerConnection.createDataChannel", true)) {
    return false;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<nsIDOMDataChannel>(self->CreateDataChannel(NonNullHelper(Constify(arg0)), Constify(arg1), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj))));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (!WrapObject(cx, result, args.rval())) {
    return false;
  }
  return true;
}

static const JSJitInfo createDataChannel_methodinfo = {
  { (JSJitGetterOp)createDataChannel },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Method,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_OBJECT,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
get_ondatachannel(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitGetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  RefPtr<EventHandlerNonNull> result(self->GetOndatachannel(rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  if (result) {
    args.rval().setObject(*GetCallbackFromCallbackObject(result));
    if (!MaybeWrapObjectOrNullValue(cx, args.rval())) {
      return false;
    }
    return true;
  } else {
    args.rval().setNull();
    return true;
  }
}

static bool
set_ondatachannel(JSContext* cx, JS::Handle<JSObject*> obj, mozilla::dom::RTCPeerConnection* self, JSJitSetterCallArgs args)
{
  Maybe<JS::Rooted<JSObject*> > unwrappedObj;
  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  if (objIsXray) {
    unwrappedObj.emplace(cx, obj);
  }
  RootedCallback<RefPtr<binding_detail::FastEventHandlerNonNull>> arg0(cx);
  if (args[0].isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &args[0].toObject());
        arg0 = new binding_detail::FastEventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    arg0 = nullptr;
  }
  if (objIsXray) {
    unwrappedObj.ref() = js::CheckedUnwrap(unwrappedObj.ref());
    if (!unwrappedObj.ref()) {
      return false;
    }
  }
  binding_detail::FastErrorResult rv;
  self->SetOndatachannel(Constify(arg0), rv, js::GetObjectCompartment(unwrappedObj ? *unwrappedObj : obj));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));

  return true;
}

static const JSJitInfo ondatachannel_getterinfo = {
  { (JSJitGetterOp)get_ondatachannel },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Getter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNKNOWN,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");
static const JSJitInfo ondatachannel_setterinfo = {
  { (JSJitGetterOp)set_ondatachannel },
  { prototypes::id::RTCPeerConnection },
  { PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth },
  JSJitInfo::Setter,
  JSJitInfo::AliasEverything, /* aliasSet.  Not relevant for setters. */
  JSVAL_TYPE_UNDEFINED,  /* returnType.  Not relevant for setters. */
  false,  /* isInfallible. False in setters. */
  false,  /* isMovable.  Not relevant for setters. */
  false, /* isEliminatable.  Not relevant for setters. */
  false, /* isAlwaysInSlot.  Only relevant for getters. */
  false, /* isLazilyCachedInSlot.  Only relevant for getters. */
  false,  /* isTypedMethod.  Only relevant for methods. */
  0   /* Reserved slot index, if we're stored in a slot, else 0. */
};
static_assert(0 <= JSJitInfo::maxSlotIndex, "We won't fit");
static_assert(0 < 1, "There is no slot for us");

static bool
_addProperty(JSContext* cx, JS::Handle<JSObject*> obj, JS::Handle<jsid> id, JS::Handle<JS::Value> val)
{
  mozilla::dom::RTCPeerConnection* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::RTCPeerConnection>(obj);
  // We don't want to preserve if we don't have a wrapper, and we
  // obviously can't preserve if we're not initialized.
  if (self && self->GetWrapperPreserveColor()) {
    PreserveWrapper(self);
  }
  return true;
}

static void
_finalize(js::FreeOp* fop, JSObject* obj)
{
  mozilla::dom::RTCPeerConnection* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::RTCPeerConnection>(obj);
  if (self) {
    ClearWrapper(self, self);
    AddForDeferredFinalization<mozilla::dom::RTCPeerConnection>(self);
  }
}

static void
_objectMoved(JSObject* obj, const JSObject* old)
{
  mozilla::dom::RTCPeerConnection* self = UnwrapPossiblyNotInitializedDOMObject<mozilla::dom::RTCPeerConnection>(obj);
  if (self) {
    UpdateWrapper(self, self, obj, old);
  }
}

static const JSFunctionSpec sStaticMethods_specs[] = {
  JS_FNSPEC("generateCertificate", StaticMethodPromiseWrapper, &generateCertificate_methodinfo, 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sStaticMethods[] = {
  { nullptr, &sStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static jsid sStaticMethods_ids[2];

static const JSFunctionSpec sChromeStaticMethods_specs[] = {
  JS_FNSPEC("_create", RTCPeerConnection::_Create, nullptr, 2, 0, nullptr),
  JS_FS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sChromeStaticMethods[] = {
  { nullptr, &sChromeStaticMethods_specs[0] },
  { nullptr, nullptr }
};

static jsid sChromeStaticMethods_ids[2];

static const JSFunctionSpec sMethods_specs[] = {
  JS_FNSPEC("setIdentityProvider", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&setIdentityProvider_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getIdentityAssertion", GenericPromiseReturningBindingMethod, reinterpret_cast<const JSJitInfo*>(&getIdentityAssertion_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FS_END,
  JS_FNSPEC("createOffer", GenericPromiseReturningBindingMethod, reinterpret_cast<const JSJitInfo*>(&createOffer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("createAnswer", GenericPromiseReturningBindingMethod, reinterpret_cast<const JSJitInfo*>(&createAnswer_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setLocalDescription", GenericPromiseReturningBindingMethod, reinterpret_cast<const JSJitInfo*>(&setLocalDescription_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("setRemoteDescription", GenericPromiseReturningBindingMethod, reinterpret_cast<const JSJitInfo*>(&setRemoteDescription_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("addIceCandidate", GenericPromiseReturningBindingMethod, reinterpret_cast<const JSJitInfo*>(&addIceCandidate_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getConfiguration", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getConfiguration_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getLocalStreams", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getLocalStreams_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getRemoteStreams", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getRemoteStreams_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getStreamById", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getStreamById_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("addStream", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&addStream_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("addTrack", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&addTrack_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("removeTrack", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&removeTrack_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getSenders", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getSenders_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getReceivers", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&getReceivers_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("close", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&close_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("getStats", GenericPromiseReturningBindingMethod, reinterpret_cast<const JSJitInfo*>(&getStats_methodinfo), 0, JSPROP_ENUMERATE, nullptr),
  JS_FNSPEC("createDataChannel", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&createDataChannel_methodinfo), 1, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};

static PrefableDisablers sMethods_disablers0 = {
  true, false, 0, nullptr
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sMethods[] = {
  { &sMethods_disablers0, &sMethods_specs[0] },
  { nullptr, &sMethods_specs[3] },
  { nullptr, nullptr }
};

static jsid sMethods_ids[21];

static const JSFunctionSpec sChromeMethods_specs[] = {
  JS_FNSPEC("mozSelectSsrc", GenericBindingMethod, reinterpret_cast<const JSJitInfo*>(&mozSelectSsrc_methodinfo), 2, JSPROP_ENUMERATE, nullptr),
  JS_FS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSFunctionSpec> sChromeMethods[] = {
  { nullptr, &sChromeMethods_specs[0] },
  { nullptr, nullptr }
};

static jsid sChromeMethods_ids[2];

static const JSPropertySpec sAttributes_specs[] = {
  { "localDescription", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &localDescription_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "remoteDescription", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &remoteDescription_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "signalingState", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &signalingState_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "canTrickleIceCandidates", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &canTrickleIceCandidates_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "iceGatheringState", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &iceGatheringState_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "iceConnectionState", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &iceConnectionState_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "peerIdentity", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &peerIdentity_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  { "idpLoginUrl", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &idpLoginUrl_getterinfo } }, JSNATIVE_WRAPPER(nullptr) } } },
  JS_PS_END,
  { "onnegotiationneeded", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &onnegotiationneeded_getterinfo } }, { { GenericBindingSetter, &onnegotiationneeded_setterinfo } } } } },
  { "onicecandidate", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &onicecandidate_getterinfo } }, { { GenericBindingSetter, &onicecandidate_setterinfo } } } } },
  { "onsignalingstatechange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &onsignalingstatechange_getterinfo } }, { { GenericBindingSetter, &onsignalingstatechange_setterinfo } } } } },
  { "onaddstream", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &onaddstream_getterinfo } }, { { GenericBindingSetter, &onaddstream_setterinfo } } } } },
  { "onaddtrack", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &onaddtrack_getterinfo } }, { { GenericBindingSetter, &onaddtrack_setterinfo } } } } },
  { "ontrack", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &ontrack_getterinfo } }, { { GenericBindingSetter, &ontrack_setterinfo } } } } },
  { "onremovestream", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &onremovestream_getterinfo } }, { { GenericBindingSetter, &onremovestream_setterinfo } } } } },
  { "oniceconnectionstatechange", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &oniceconnectionstatechange_getterinfo } }, { { GenericBindingSetter, &oniceconnectionstatechange_setterinfo } } } } },
  { "ondatachannel", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &ondatachannel_getterinfo } }, { { GenericBindingSetter, &ondatachannel_setterinfo } } } } },
  JS_PS_END
};

static PrefableDisablers sAttributes_disablers7 = {
  true, false, 0, nullptr
};

// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSPropertySpec> sAttributes[] = {
  { nullptr, &sAttributes_specs[0] },
  { &sAttributes_disablers7, &sAttributes_specs[7] },
  { nullptr, &sAttributes_specs[10] },
  { nullptr, nullptr }
};

static jsid sAttributes_ids[20];

static const JSPropertySpec sChromeAttributes_specs[] = {
  { "id", JSPROP_SHARED | JSPROP_ENUMERATE, { { { { GenericBindingGetter, &id_getterinfo } }, { { GenericBindingSetter, &id_setterinfo } } } } },
  JS_PS_END
};


// Can't be const because the pref-enabled boolean needs to be writable
static Prefable<const JSPropertySpec> sChromeAttributes[] = {
  { nullptr, &sChromeAttributes_specs[0] },
  { nullptr, nullptr }
};

static jsid sChromeAttributes_ids[2];


static const NativePropertiesN<3> sNativeProperties = {
  -1,
  true,  0 /* sStaticMethods */,
  false, 0,
  true,  1 /* sMethods */,
  true,  2 /* sAttributes */,
  false, 0,
  false, 0,
  false, 0,
  {
    { sStaticMethods, sStaticMethods_ids, sStaticMethods_specs },
    { sMethods, sMethods_ids, sMethods_specs },
    { sAttributes, sAttributes_ids, sAttributes_specs }
  }
};

static const NativePropertiesN<3> sChromeOnlyNativeProperties = {
  -1,
  true,  0 /* sChromeStaticMethods */,
  false, 0,
  true,  1 /* sChromeMethods */,
  true,  2 /* sChromeAttributes */,
  false, 0,
  false, 0,
  false, 0,
  {
    { sChromeStaticMethods, sChromeStaticMethods_ids, sChromeStaticMethods_specs },
    { sChromeMethods, sChromeMethods_ids, sChromeMethods_specs },
    { sChromeAttributes, sChromeAttributes_ids, sChromeAttributes_specs }
  }
};

static bool
_constructor(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  JS::Rooted<JSObject*> obj(cx, &args.callee());
  if (!args.isConstructing()) {
    // XXXbz wish I could get the name from the callee instead of
    // Adding more relocations
    return ThrowConstructorWithoutNew(cx, "RTCPeerConnection");
  }

  GlobalObject global(cx, obj);
  if (global.Failed()) {
    return false;
  }

  JS::Rooted<JSObject*> desiredProto(cx);
  if (!GetDesiredProto(cx, args, &desiredProto)) {
    return false;
  }

  bool objIsXray = xpc::WrapperFactory::IsXrayWrapper(obj);
  binding_detail::FastRTCConfiguration arg0;
  if (!arg0.Init(cx, (args.hasDefined(0)) ? args[0] : JS::NullHandleValue,  "Argument 1 of RTCPeerConnection.constructor", true)) {
    return false;
  }
  Optional<JS::Handle<JSObject*>> arg1;
  if (args.hasDefined(1)) {
    arg1.Construct(cx);
    if (args[1].isObject()) {
      if ((true) && !CallerSubsumes(args[1])) {
        ThrowErrorMessage(cx, MSG_PERMISSION_DENIED_TO_PASS_ARG, "argument 2 of RTCPeerConnection.constructor");
        return false;
      }
      arg1.Value() = &args[1].toObject();
    } else if (args[1].isNullOrUndefined()) {
      arg1.Value() = nullptr;
    } else {
      ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection.constructor");
      return false;
    }
  }
  Maybe<JSAutoCompartment> ac;
  if (objIsXray) {
    obj = js::CheckedUnwrap(obj);
    if (!obj) {
      return false;
    }
    ac.emplace(cx, obj);
    if (!JS_WrapObject(cx, &desiredProto)) {
      return false;
    }
    if (arg1.WasPassed()) {
      if (!JS_WrapObject(cx, &arg1.Value())) {
        return false;
      }
    }
  }
  binding_detail::FastErrorResult rv;
  auto result(StrongOrRawPtr<mozilla::dom::RTCPeerConnection>(mozilla::dom::RTCPeerConnection::Constructor(global, cx, Constify(arg0), Constify(arg1), rv)));
  if (MOZ_UNLIKELY(rv.MaybeSetPendingException(cx))) {
    return false;
  }
  MOZ_ASSERT(!JS_IsExceptionPending(cx));
  static_assert(!IsPointer<decltype(result)>::value,
                "NewObject implies that we need to keep the object alive with a strong reference.");
  if (!GetOrCreateDOMReflector(cx, result, args.rval(), desiredProto)) {
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    return false;
  }
  return true;
}

static const js::ClassOps sInterfaceObjectClassOps = {
    nullptr,               /* addProperty */
    nullptr,               /* delProperty */
    nullptr,               /* getProperty */
    nullptr,               /* setProperty */
    nullptr,               /* enumerate */
    nullptr,               /* resolve */
    nullptr,               /* mayResolve */
    nullptr,               /* finalize */
    _constructor, /* call */
    nullptr,               /* hasInstance */
    _constructor, /* construct */
    nullptr,               /* trace */
};

static const DOMIfaceAndProtoJSClass sInterfaceObjectClass = {
  {
    "Function",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_SLOTS_BASE),
    &sInterfaceObjectClassOps,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    &sInterfaceObjectClassObjectOps
  },
  eInterface,
  true,
  prototypes::id::RTCPeerConnection,
  PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth,
  sNativePropertyHooks,
  "function RTCPeerConnection() {\n    [native code]\n}",
  EventTargetBinding::GetConstructorObject
};

static const DOMIfaceAndProtoJSClass sPrototypeClass = {
  {
    "RTCPeerConnectionPrototype",
    JSCLASS_IS_DOMIFACEANDPROTOJSCLASS | JSCLASS_HAS_RESERVED_SLOTS(DOM_INTERFACE_PROTO_SLOTS_BASE),
    JS_NULL_CLASS_OPS,
    JS_NULL_CLASS_SPEC,
    JS_NULL_CLASS_EXT,
    JS_NULL_OBJECT_OPS
  },
  eInterfacePrototype,
  false,
  prototypes::id::RTCPeerConnection,
  PrototypeTraits<prototypes::id::RTCPeerConnection>::Depth,
  sNativePropertyHooks,
  "[object RTCPeerConnectionPrototype]",
  EventTargetBinding::GetProtoObject
};

bool
ConstructorEnabled(JSContext* aCx, JS::Handle<JSObject*> aObj)
{
  return Preferences::GetBool("media.peerconnection.enabled");
}

JSObject*
DefineDOMInterface(JSContext* aCx, JS::Handle<JSObject*> aGlobal, JS::Handle<jsid> id, bool aDefineOnGlobal)
{
  return GetConstructorObjectHandle(aCx, aDefineOnGlobal);
}

static const js::ClassOps sClassOps = {
  _addProperty, /* addProperty */
  nullptr,               /* delProperty */
  nullptr,               /* getProperty */
  nullptr,               /* setProperty */
  nullptr, /* enumerate */
  nullptr, /* resolve */
  nullptr, /* mayResolve */
  _finalize, /* finalize */
  nullptr, /* call */
  nullptr,               /* hasInstance */
  nullptr,               /* construct */
  nullptr, /* trace */
};

static const js::ClassExtension sClassExtension = {
  nullptr, /* weakmapKeyDelegateOp */
  _objectMoved /* objectMovedOp */
};

static const DOMJSClass sClass = {
  { "RTCPeerConnection",
    JSCLASS_IS_DOMJSCLASS | JSCLASS_FOREGROUND_FINALIZE | JSCLASS_HAS_RESERVED_SLOTS(1),
    &sClassOps,
    JS_NULL_CLASS_SPEC,
    &sClassExtension,
    JS_NULL_OBJECT_OPS
  },
  { prototypes::id::EventTarget, prototypes::id::RTCPeerConnection, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count, prototypes::id::_ID_Count },
  IsBaseOf<nsISupports, mozilla::dom::RTCPeerConnection >::value,
  sNativePropertyHooks,
  FindAssociatedGlobalForNative<mozilla::dom::RTCPeerConnection>::Get,
  GetProtoObjectHandle,
  GetCCParticipant<mozilla::dom::RTCPeerConnection>::Get()
};
static_assert(1 == DOM_INSTANCE_RESERVED_SLOTS,
              "Must have the right minimal number of reserved slots.");
static_assert(1 >= 1,
              "Must have enough reserved slots.");

const JSClass*
GetJSClass()
{
  return sClass.ToJSClass();
}

bool
Wrap(JSContext* aCx, mozilla::dom::RTCPeerConnection* aObject, nsWrapperCache* aCache, JS::Handle<JSObject*> aGivenProto, JS::MutableHandle<JSObject*> aReflector)
{
  MOZ_ASSERT(static_cast<mozilla::dom::RTCPeerConnection*>(aObject) ==
             reinterpret_cast<mozilla::dom::RTCPeerConnection*>(aObject),
             "Multiple inheritance for mozilla::dom::RTCPeerConnection is broken.");
  MOZ_ASSERT(static_cast<mozilla::dom::EventTarget*>(aObject) ==
             reinterpret_cast<mozilla::dom::EventTarget*>(aObject),
             "Multiple inheritance for mozilla::dom::EventTarget is broken.");
  MOZ_ASSERT(ToSupportsIsCorrect(aObject));
  MOZ_ASSERT(!aCache->GetWrapper(),
             "You should probably not be using Wrap() directly; use "
             "GetOrCreateDOMReflector instead");

  MOZ_ASSERT(ToSupportsIsOnPrimaryInheritanceChain(aObject, aCache),
             "nsISupports must be on our primary inheritance chain");

  JS::Rooted<JSObject*> global(aCx, FindAssociatedGlobal(aCx, aObject->GetParentObject()));
  if (!global) {
    return false;
  }
  MOZ_ASSERT(JS_IsGlobalObject(global));
  MOZ_ASSERT(!JS::ObjectIsMarkedGray(global));

  // That might have ended up wrapping us already, due to the wonders
  // of XBL.  Check for that, and bail out as needed.
  aReflector.set(aCache->GetWrapper());
  if (aReflector) {
#ifdef DEBUG
    binding_detail::AssertReflectorHasGivenProto(aCx, aReflector, aGivenProto);
#endif // DEBUG
    return true;
  }

  JSAutoCompartment ac(aCx, global);
  JS::Handle<JSObject*> canonicalProto = GetProtoObjectHandle(aCx);
  if (!canonicalProto) {
    return false;
  }
  JS::Rooted<JSObject*> proto(aCx);
  if (aGivenProto) {
    proto = aGivenProto;
    // Unfortunately, while aGivenProto was in the compartment of aCx
    // coming in, we changed compartments to that of "parent" so may need
    // to wrap the proto here.
    if (js::GetContextCompartment(aCx) != js::GetObjectCompartment(proto)) {
      if (!JS_WrapObject(aCx, &proto)) {
        return false;
      }
    }
  } else {
    proto = canonicalProto;
  }

  BindingJSObjectCreator<mozilla::dom::RTCPeerConnection> creator(aCx);
  creator.CreateObject(aCx, sClass.ToJSClass(), proto, aObject, aReflector);
  if (!aReflector) {
    return false;
  }

  aCache->SetWrapper(aReflector);
  creator.InitializationSucceeded();

  MOZ_ASSERT(aCache->GetWrapperPreserveColor() &&
             aCache->GetWrapperPreserveColor() == aReflector);
  // If proto != canonicalProto, we have to preserve our wrapper;
  // otherwise we won't be able to properly recreate it later, since
  // we won't know what proto to use.  Note that we don't check
  // aGivenProto here, since it's entirely possible (and even
  // somewhat common) to have a non-null aGivenProto which is the
  // same as canonicalProto.
  if (proto != canonicalProto) {
    PreserveWrapper(aObject);
  }

  return true;
}

const NativePropertyHooks sNativePropertyHooks[] = { {
  nullptr,
  nullptr,
  nullptr,
  { sNativeProperties.Upcast(), sChromeOnlyNativeProperties.Upcast() },
  prototypes::id::RTCPeerConnection,
  constructors::id::RTCPeerConnection,
  EventTargetBinding::sNativePropertyHooks,
  &DefaultXrayExpandoObjectClass
} };

void
CreateInterfaceObjects(JSContext* aCx, JS::Handle<JSObject*> aGlobal, ProtoAndIfaceCache& aProtoAndIfaceCache, bool aDefineOnGlobal)
{
  JS::Handle<JSObject*> parentProto(EventTargetBinding::GetProtoObjectHandle(aCx));
  if (!parentProto) {
    return;
  }

  JS::Handle<JSObject*> constructorProto(EventTargetBinding::GetConstructorObjectHandle(aCx));
  if (!constructorProto) {
    return;
  }

  static bool sIdsInited = false;
  if (!sIdsInited && NS_IsMainThread()) {
    if (!InitIds(aCx, sChromeStaticMethods, sChromeStaticMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sStaticMethods, sStaticMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sChromeMethods, sChromeMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sMethods, sMethods_ids)) {
      return;
    }
    if (!InitIds(aCx, sChromeAttributes, sChromeAttributes_ids)) {
      return;
    }
    if (!InitIds(aCx, sAttributes, sAttributes_ids)) {
      return;
    }
    sIdsInited = true;
  }

  static bool sPrefCachesInited = false;
  if (!sPrefCachesInited && NS_IsMainThread()) {
    sPrefCachesInited = true;
    Preferences::AddBoolVarCache(&sMethods[0].disablers->enabled, "media.peerconnection.identity.enabled");
    Preferences::AddBoolVarCache(&sAttributes[1].disablers->enabled, "media.peerconnection.identity.enabled");
  }

  JS::Heap<JSObject*>* protoCache = &aProtoAndIfaceCache.EntrySlotOrCreate(prototypes::id::RTCPeerConnection);
  JS::Heap<JSObject*>* interfaceCache = &aProtoAndIfaceCache.EntrySlotOrCreate(constructors::id::RTCPeerConnection);
  dom::CreateInterfaceObjects(aCx, aGlobal, parentProto,
                              &sPrototypeClass.mBase, protoCache,
                              constructorProto, &sInterfaceObjectClass.mBase, 0, nullptr,
                              interfaceCache,
                              sNativeProperties.Upcast(),
                              nsContentUtils::ThreadsafeIsCallerChrome() ? sChromeOnlyNativeProperties.Upcast() : nullptr,
                              "RTCPeerConnection", aDefineOnGlobal,
                              nullptr,
                              false);
}

JS::Handle<JSObject*>
GetProtoObjectHandle(JSContext* aCx)
{
  /* Get the interface prototype object for this class.  This will create the
     object as needed. */
  bool aDefineOnGlobal = true;

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  JSObject* global = JS::CurrentGlobalOrNull(aCx);
  if (!(js::GetObjectClass(global)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the interface objects are already installed */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(global);
  if (!protoAndIfaceCache.EntrySlotIfExists(prototypes::id::RTCPeerConnection)) {
    JS::Rooted<JSObject*> rootedGlobal(aCx, global);
    CreateInterfaceObjects(aCx, rootedGlobal, protoAndIfaceCache, aDefineOnGlobal);
  }

  /*
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceCache is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   *
   * Calling address() avoids the read read barrier that does gray
   * unmarking, but it's not possible for the object to be gray here.
   */

  const JS::Heap<JSObject*>& entrySlot = protoAndIfaceCache.EntrySlotMustExist(prototypes::id::RTCPeerConnection);
  MOZ_ASSERT_IF(entrySlot, !JS::ObjectIsMarkedGray(entrySlot));
  return JS::Handle<JSObject*>::fromMarkedLocation(entrySlot.address());
}

JSObject*
GetProtoObject(JSContext* aCx)
{
  return GetProtoObjectHandle(aCx);
}

JS::Handle<JSObject*>
GetConstructorObjectHandle(JSContext* aCx, bool aDefineOnGlobal)
{
  /* Get the interface object for this class.  This will create the object as
     needed. */

  /* Make sure our global is sane.  Hopefully we can remove this sometime */
  JSObject* global = JS::CurrentGlobalOrNull(aCx);
  if (!(js::GetObjectClass(global)->flags & JSCLASS_DOM_GLOBAL)) {
    return nullptr;
  }

  /* Check to see whether the interface objects are already installed */
  ProtoAndIfaceCache& protoAndIfaceCache = *GetProtoAndIfaceCache(global);
  if (!protoAndIfaceCache.EntrySlotIfExists(constructors::id::RTCPeerConnection)) {
    JS::Rooted<JSObject*> rootedGlobal(aCx, global);
    CreateInterfaceObjects(aCx, rootedGlobal, protoAndIfaceCache, aDefineOnGlobal);
  }

  /*
   * The object might _still_ be null, but that's OK.
   *
   * Calling fromMarkedLocation() is safe because protoAndIfaceCache is
   * traced by TraceProtoAndIfaceCache() and its contents are never
   * changed after they have been set.
   *
   * Calling address() avoids the read read barrier that does gray
   * unmarking, but it's not possible for the object to be gray here.
   */

  const JS::Heap<JSObject*>& entrySlot = protoAndIfaceCache.EntrySlotMustExist(constructors::id::RTCPeerConnection);
  MOZ_ASSERT_IF(entrySlot, !JS::ObjectIsMarkedGray(entrySlot));
  return JS::Handle<JSObject*>::fromMarkedLocation(entrySlot.address());
}

JSObject*
GetConstructorObject(JSContext* aCx)
{
  return GetConstructorObjectHandle(aCx);
}

} // namespace RTCPeerConnectionBinding



void
RTCPeerConnectionJSImpl::SetIdentityProvider(const nsAString& provider, const Optional<nsAString>& protocol, const Optional<nsAString>& username, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.setIdentityProvider", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(3)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 3;

  do {
    if (username.WasPassed()) {
      nsString mutableStr(username.Value());
      if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[2])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 3) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[2].setUndefined();
    }
  } while (0);

  do {
    if (protocol.WasPassed()) {
      nsString mutableStr(protocol.Value());
      if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[1])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 2) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[1].setUndefined();
    }
  } while (0);

  do {
    nsString mutableStr(provider);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->setIdentityProvider_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::GetIdentityAssertion(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getIdentityAssertion", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getIdentityAssertion_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.getIdentityAssertion"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.getIdentityAssertion"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::CreateOffer(const RTCOfferOptions& options, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.createOffer", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 1;

  do {
    if (!options.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->createOffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createOffer"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createOffer"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::CreateOffer(RTCSessionDescriptionCallback& successCallback, RTCPeerConnectionErrorCallback& failureCallback, const RTCOfferOptions& options, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.createOffer", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(3)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 3;

  do {
    if (!options.ToObjectInternal(cx, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    argv[1].setObject(*GetCallbackFromCallbackObject(failureCallback));
    if (!MaybeWrapObjectValue(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    argv[0].setObject(*GetCallbackFromCallbackObject(successCallback));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->createOffer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createOffer"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createOffer"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::CreateAnswer(const RTCAnswerOptions& options, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.createAnswer", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 1;

  do {
    if (!options.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->createAnswer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createAnswer"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createAnswer"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::CreateAnswer(RTCSessionDescriptionCallback& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.createAnswer", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(2)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 2;

  do {
    argv[1].setObject(*GetCallbackFromCallbackObject(failureCallback));
    if (!MaybeWrapObjectValue(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    argv[0].setObject(*GetCallbackFromCallbackObject(successCallback));
    if (!MaybeWrapObjectValue(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->createAnswer_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createAnswer"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.createAnswer"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::SetLocalDescription(RTCSessionDescription& description, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.setLocalDescription", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, description, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->setLocalDescription_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setLocalDescription"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setLocalDescription"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::SetLocalDescription(RTCSessionDescription& description, VoidFunction& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.setLocalDescription", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(3)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 3;

  do {
    argv[2].setObject(*GetCallbackFromCallbackObject(failureCallback));
    if (!MaybeWrapObjectValue(cx, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    argv[1].setObject(*GetCallbackFromCallbackObject(successCallback));
    if (!MaybeWrapObjectValue(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    if (!GetOrCreateDOMReflector(cx, description, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->setLocalDescription_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setLocalDescription"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setLocalDescription"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::SetRemoteDescription(RTCSessionDescription& description, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.setRemoteDescription", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, description, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->setRemoteDescription_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setRemoteDescription"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setRemoteDescription"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::SetRemoteDescription(RTCSessionDescription& description, VoidFunction& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.setRemoteDescription", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(3)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 3;

  do {
    argv[2].setObject(*GetCallbackFromCallbackObject(failureCallback));
    if (!MaybeWrapObjectValue(cx, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    argv[1].setObject(*GetCallbackFromCallbackObject(successCallback));
    if (!MaybeWrapObjectValue(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    if (!GetOrCreateDOMReflector(cx, description, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->setRemoteDescription_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setRemoteDescription"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.setRemoteDescription"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::AddIceCandidate(RTCIceCandidate& candidate, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.addIceCandidate", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, candidate, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->addIceCandidate_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.addIceCandidate"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.addIceCandidate"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::AddIceCandidate(RTCIceCandidate& candidate, VoidFunction& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.addIceCandidate", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(3)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 3;

  do {
    argv[2].setObject(*GetCallbackFromCallbackObject(failureCallback));
    if (!MaybeWrapObjectValue(cx, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    argv[1].setObject(*GetCallbackFromCallbackObject(successCallback));
    if (!MaybeWrapObjectValue(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    if (!GetOrCreateDOMReflector(cx, candidate, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->addIceCandidate_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.addIceCandidate"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.addIceCandidate"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

void
RTCPeerConnectionJSImpl::GetConfiguration(RTCConfiguration& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getConfiguration", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getConfiguration_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  RTCConfiguration& rvalDecl(aRetVal);
  if (!rvalDecl.Init(cx, rval,  "Return value of RTCPeerConnection.getConfiguration", false)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::GetLocalStreams(nsTArray<RefPtr<DOMMediaStream>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getLocalStreams", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getLocalStreams_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::DOMMediaStream>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getLocalStreams");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::DOMMediaStream>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::DOMMediaStream>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::DOMMediaStream>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::DOMMediaStream>::value, "We can only store refcounted classes.");{
          nsresult rv = UnwrapObject<prototypes::id::MediaStream, mozilla::DOMMediaStream>(&temp, slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element of return value of RTCPeerConnection.getLocalStreams", "MediaStream");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Element of return value of RTCPeerConnection.getLocalStreams");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getLocalStreams");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.SwapElements(rvalDecl);
}

void
RTCPeerConnectionJSImpl::GetRemoteStreams(nsTArray<RefPtr<DOMMediaStream>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getRemoteStreams", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getRemoteStreams_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::DOMMediaStream>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getRemoteStreams");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::DOMMediaStream>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::DOMMediaStream>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::DOMMediaStream>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::DOMMediaStream>::value, "We can only store refcounted classes.");{
          nsresult rv = UnwrapObject<prototypes::id::MediaStream, mozilla::DOMMediaStream>(&temp, slot);
          if (NS_FAILED(rv)) {
            ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element of return value of RTCPeerConnection.getRemoteStreams", "MediaStream");
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return;
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Element of return value of RTCPeerConnection.getRemoteStreams");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getRemoteStreams");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.SwapElements(rvalDecl);
}

already_AddRefed<DOMMediaStream>
RTCPeerConnectionJSImpl::GetStreamById(const nsAString& streamId, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getStreamById", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 1;

  do {
    nsString mutableStr(streamId);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getStreamById_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::DOMMediaStream> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::DOMMediaStream>::value, "We can only store refcounted classes.");{
      nsresult rv = UnwrapObject<prototypes::id::MediaStream, mozilla::DOMMediaStream>(rval, rvalDecl);
      if (NS_FAILED(rv)) {
        ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Return value of RTCPeerConnection.getStreamById", "MediaStream");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Return value of RTCPeerConnection.getStreamById");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
RTCPeerConnectionJSImpl::AddStream(DOMMediaStream& stream, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.addStream", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, stream, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->addStream_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<RTCRtpSender>
RTCPeerConnectionJSImpl::AddTrack(MediaStreamTrack& track, DOMMediaStream& stream, const nsTArray<OwningNonNull<DOMMediaStream>>& moreStreams, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.addTrack", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize((3 - 1) + moreStreams.Length())) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = (3 - 1) + moreStreams.Length();

  do {
    for (uint32_t idx = 0; idx < moreStreams.Length(); ++idx) {
      if (!GetOrCreateDOMReflector(cx, moreStreams[idx], argv[2 + idx])) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
      continue;
    }
    break;
  } while (0);

  do {
    if (!GetOrCreateDOMReflector(cx, stream, argv[1])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    if (!GetOrCreateDOMReflector(cx, track, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->addTrack_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<mozilla::dom::RTCRtpSender> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::RTCRtpSender>::value, "We can only store refcounted classes.");{
      nsresult rv = UnwrapObject<prototypes::id::RTCRtpSender, mozilla::dom::RTCRtpSender>(rval, rvalDecl);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          if (!GetContentGlobalForJSImplementedObject(cx, Callback(), getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          rvalDecl = new mozilla::dom::RTCRtpSender(jsImplSourceObj, contentGlobal);
        } else {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Return value of RTCPeerConnection.addTrack", "RTCRtpSender");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Return value of RTCPeerConnection.addTrack");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
RTCPeerConnectionJSImpl::RemoveTrack(RTCRtpSender& sender, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.removeTrack", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 1;

  do {
    if (!GetOrCreateDOMReflector(cx, sender, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->removeTrack_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
RTCPeerConnectionJSImpl::GetSenders(nsTArray<RefPtr<RTCRtpSender>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getSenders", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getSenders_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::RTCRtpSender>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getSenders");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::RTCRtpSender>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::RTCRtpSender>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::RTCRtpSender>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::RTCRtpSender>::value, "We can only store refcounted classes.");{
          nsresult rv = UnwrapObject<prototypes::id::RTCRtpSender, mozilla::dom::RTCRtpSender>(&temp, slot);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              if (!GetContentGlobalForJSImplementedObject(cx, Callback(), getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              slot = new mozilla::dom::RTCRtpSender(jsImplSourceObj, contentGlobal);
            } else {
              ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element of return value of RTCPeerConnection.getSenders", "RTCRtpSender");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Element of return value of RTCPeerConnection.getSenders");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getSenders");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.SwapElements(rvalDecl);
}

void
RTCPeerConnectionJSImpl::GetReceivers(nsTArray<RefPtr<RTCRtpReceiver>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getReceivers", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getReceivers_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
  Sequence<RefPtr<mozilla::dom::RTCRtpReceiver>> rvalDecl;
  if (rval.isObject()) {
    JS::ForOfIterator iter(cx);
    if (!iter.init(rval, JS::ForOfIterator::AllowNonIterable)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    if (!iter.valueIsIterable()) {
      ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getReceivers");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    Sequence<RefPtr<mozilla::dom::RTCRtpReceiver>> &arr = rvalDecl;
    JS::Rooted<JS::Value> temp(cx);
    while (true) {
      bool done;
      if (!iter.next(&temp, &done)) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      if (done) {
        break;
      }
      RefPtr<mozilla::dom::RTCRtpReceiver>* slotPtr = arr.AppendElement(mozilla::fallible);
      if (!slotPtr) {
        JS_ReportOutOfMemory(cx);
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      RefPtr<mozilla::dom::RTCRtpReceiver>& slot = *slotPtr;
      if (temp.isObject()) {
        static_assert(IsRefcounted<mozilla::dom::RTCRtpReceiver>::value, "We can only store refcounted classes.");{
          nsresult rv = UnwrapObject<prototypes::id::RTCRtpReceiver, mozilla::dom::RTCRtpReceiver>(&temp, slot);
          if (NS_FAILED(rv)) {
            // Be careful to not wrap random DOM objects here, even if
            // they're wrapped in opaque security wrappers for some reason.
            // XXXbz Wish we could check for a JS-implemented object
            // that already has a content reflection...
            if (!IsDOMObject(js::UncheckedUnwrap(&temp.toObject()))) {
              nsCOMPtr<nsIGlobalObject> contentGlobal;
              if (!GetContentGlobalForJSImplementedObject(cx, Callback(), getter_AddRefs(contentGlobal))) {
                aRv.Throw(NS_ERROR_UNEXPECTED);
                return;
              }
              JS::Rooted<JSObject*> jsImplSourceObj(cx, &temp.toObject());
              slot = new mozilla::dom::RTCRtpReceiver(jsImplSourceObj, contentGlobal);
            } else {
              ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Element of return value of RTCPeerConnection.getReceivers", "RTCRtpReceiver");
              aRv.Throw(NS_ERROR_UNEXPECTED);
              return;
            }
          }
        }
      } else {
        ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Element of return value of RTCPeerConnection.getReceivers");
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
    }
  } else {
    ThrowErrorMessage(cx, MSG_NOT_SEQUENCE, "Return value of RTCPeerConnection.getReceivers");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal.SwapElements(rvalDecl);
}

void
RTCPeerConnectionJSImpl::MozSelectSsrc(RTCRtpReceiver& receiver, uint16_t ssrcIndex, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.mozSelectSsrc", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(2)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 2;

  do {
    argv[1].setInt32(int32_t(ssrcIndex));
    break;
  } while (0);

  do {
    if (!GetOrCreateDOMReflector(cx, receiver, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->mozSelectSsrc_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

void
RTCPeerConnectionJSImpl::Close(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.close", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->close_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::empty(), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::GetStats(const Optional<MediaStreamTrack*>& selector, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getStats", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 1;

  do {
    if (selector.WasPassed()) {
      if (!selector.Value()) {
        argv[0].setNull();
        break;
      }
      if (!GetOrCreateDOMReflector(cx, selector.Value(), argv[0])) {
        MOZ_ASSERT(true || JS_IsExceptionPending(cx));
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return nullptr;
      }
      break;
    } else if (argc == 1) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[0].setUndefined();
    }
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getStats_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.getStats"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.getStats"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::GetStats(MediaStreamTrack* selector, RTCStatsCallback& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.getStats", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(3)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 3;

  do {
    argv[2].setObject(*GetCallbackFromCallbackObject(failureCallback));
    if (!MaybeWrapObjectValue(cx, argv[2])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    argv[1].setObject(*GetCallbackFromCallbackObject(successCallback));
    if (!MaybeWrapObjectValue(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    if (!selector) {
      argv[0].setNull();
      break;
    }
    if (!GetOrCreateDOMReflector(cx, selector, argv[0])) {
      MOZ_ASSERT(true || JS_IsExceptionPending(cx));
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->getStats_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.getStats"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.getStats"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

already_AddRefed<nsIDOMDataChannel>
RTCPeerConnectionJSImpl::CreateDataChannel(const nsAString& label, const RTCDataChannelInit& dataChannelDict, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.createDataChannel", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(2)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return nullptr;
  }
  unsigned argc = 2;

  do {
    if (!dataChannelDict.ToObjectInternal(cx, argv[1])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  do {
    nsString mutableStr(label);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->createDataChannel_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return nullptr;
  }
  RefPtr<nsIDOMDataChannel> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<nsIDOMDataChannel>::value, "We can only store refcounted classes.");RefPtr<nsIDOMDataChannel> rvalHolder;
    JS::Rooted<JSObject*> source(cx, &rval.toObject());
    if (NS_FAILED(UnwrapArg<nsIDOMDataChannel>(source, getter_AddRefs(rvalHolder)))) {
      ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Return value of RTCPeerConnection.createDataChannel", "RTCDataChannel");
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    MOZ_ASSERT(rvalHolder);
    rvalDecl = rvalHolder;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Return value of RTCPeerConnection.createDataChannel");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

void
RTCPeerConnectionJSImpl::__Init(const RTCConfiguration& configuration, const Optional<JS::Handle<JSObject*>>& constraints, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "__init", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());
  JS::AutoValueVector argv(cx);
  if (!argv.resize(2)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  unsigned argc = 2;

  do {
    if (constraints.WasPassed()) {
      if (constraints.Value()) {
                    JS::ExposeObjectToActiveJS(constraints.Value());
                  }
                  argv[1].setObjectOrNull(constraints.Value());
      if (!MaybeWrapObjectOrNullValue(cx, argv[1])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else if (argc == 2) {
      // This is our current trailing argument; reduce argc
      --argc;
    } else {
      argv[1].setUndefined();
    }
  } while (0);

  do {
    if (!configuration.ToObjectInternal(cx, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  JS::Rooted<JS::Value> callable(cx);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !GetCallableProperty(cx, atomsCache->__init_id, &callable)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  JS::Rooted<JS::Value> thisValue(cx, JS::ObjectValue(*mCallback));
  if (!JS::Call(cx, thisValue, callable,
                JS::HandleValueArray::subarray(argv, 0, argc), &rval)) {
    aRv.NoteJSContextException(cx);
    return;
  }
}

bool
RTCPeerConnectionJSImpl::InitIds(JSContext* cx, RTCPeerConnectionAtoms* atomsCache)
{
  MOZ_ASSERT(!*reinterpret_cast<jsid**>(atomsCache));

  // Initialize these in reverse order so that any failure leaves the first one
  // uninitialized.
  if (!atomsCache->__init_id.init(cx, "__init") ||
      !atomsCache->ondatachannel_id.init(cx, "ondatachannel") ||
      !atomsCache->createDataChannel_id.init(cx, "createDataChannel") ||
      !atomsCache->getStats_id.init(cx, "getStats") ||
      !atomsCache->oniceconnectionstatechange_id.init(cx, "oniceconnectionstatechange") ||
      !atomsCache->onremovestream_id.init(cx, "onremovestream") ||
      !atomsCache->ontrack_id.init(cx, "ontrack") ||
      !atomsCache->onaddtrack_id.init(cx, "onaddtrack") ||
      !atomsCache->onaddstream_id.init(cx, "onaddstream") ||
      !atomsCache->onsignalingstatechange_id.init(cx, "onsignalingstatechange") ||
      !atomsCache->onicecandidate_id.init(cx, "onicecandidate") ||
      !atomsCache->onnegotiationneeded_id.init(cx, "onnegotiationneeded") ||
      !atomsCache->close_id.init(cx, "close") ||
      !atomsCache->mozSelectSsrc_id.init(cx, "mozSelectSsrc") ||
      !atomsCache->getReceivers_id.init(cx, "getReceivers") ||
      !atomsCache->getSenders_id.init(cx, "getSenders") ||
      !atomsCache->removeTrack_id.init(cx, "removeTrack") ||
      !atomsCache->addTrack_id.init(cx, "addTrack") ||
      !atomsCache->addStream_id.init(cx, "addStream") ||
      !atomsCache->getStreamById_id.init(cx, "getStreamById") ||
      !atomsCache->getRemoteStreams_id.init(cx, "getRemoteStreams") ||
      !atomsCache->getLocalStreams_id.init(cx, "getLocalStreams") ||
      !atomsCache->getConfiguration_id.init(cx, "getConfiguration") ||
      !atomsCache->id_id.init(cx, "id") ||
      !atomsCache->idpLoginUrl_id.init(cx, "idpLoginUrl") ||
      !atomsCache->peerIdentity_id.init(cx, "peerIdentity") ||
      !atomsCache->iceConnectionState_id.init(cx, "iceConnectionState") ||
      !atomsCache->iceGatheringState_id.init(cx, "iceGatheringState") ||
      !atomsCache->canTrickleIceCandidates_id.init(cx, "canTrickleIceCandidates") ||
      !atomsCache->addIceCandidate_id.init(cx, "addIceCandidate") ||
      !atomsCache->signalingState_id.init(cx, "signalingState") ||
      !atomsCache->remoteDescription_id.init(cx, "remoteDescription") ||
      !atomsCache->localDescription_id.init(cx, "localDescription") ||
      !atomsCache->setRemoteDescription_id.init(cx, "setRemoteDescription") ||
      !atomsCache->setLocalDescription_id.init(cx, "setLocalDescription") ||
      !atomsCache->createAnswer_id.init(cx, "createAnswer") ||
      !atomsCache->createOffer_id.init(cx, "createOffer") ||
      !atomsCache->getIdentityAssertion_id.init(cx, "getIdentityAssertion") ||
      !atomsCache->setIdentityProvider_id.init(cx, "setIdentityProvider") ||
      !atomsCache->generateCertificate_id.init(cx, "generateCertificate")) {
    return false;
  }
  return true;
}


already_AddRefed<RTCSessionDescription>
RTCPeerConnectionJSImpl::GetLocalDescription(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.localDescription", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->localDescription_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::RTCSessionDescription> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::RTCSessionDescription>::value, "We can only store refcounted classes.");{
      nsresult rv = UnwrapObject<prototypes::id::RTCSessionDescription, mozilla::dom::RTCSessionDescription>(rval, rvalDecl);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          if (!GetContentGlobalForJSImplementedObject(cx, Callback(), getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          rvalDecl = new mozilla::dom::RTCSessionDescription(jsImplSourceObj, contentGlobal);
        } else {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Return value of RTCPeerConnection.localDescription", "RTCSessionDescription");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Return value of RTCPeerConnection.localDescription");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<RTCSessionDescription>
RTCPeerConnectionJSImpl::GetRemoteDescription(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.remoteDescription", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->remoteDescription_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<mozilla::dom::RTCSessionDescription> rvalDecl;
  if (rval.isObject()) {
    static_assert(IsRefcounted<mozilla::dom::RTCSessionDescription>::value, "We can only store refcounted classes.");{
      nsresult rv = UnwrapObject<prototypes::id::RTCSessionDescription, mozilla::dom::RTCSessionDescription>(rval, rvalDecl);
      if (NS_FAILED(rv)) {
        // Be careful to not wrap random DOM objects here, even if
        // they're wrapped in opaque security wrappers for some reason.
        // XXXbz Wish we could check for a JS-implemented object
        // that already has a content reflection...
        if (!IsDOMObject(js::UncheckedUnwrap(&rval.toObject()))) {
          nsCOMPtr<nsIGlobalObject> contentGlobal;
          if (!GetContentGlobalForJSImplementedObject(cx, Callback(), getter_AddRefs(contentGlobal))) {
            aRv.Throw(NS_ERROR_UNEXPECTED);
            return nullptr;
          }
          JS::Rooted<JSObject*> jsImplSourceObj(cx, &rval.toObject());
          rvalDecl = new mozilla::dom::RTCSessionDescription(jsImplSourceObj, contentGlobal);
        } else {
          ThrowErrorMessage(cx, MSG_DOES_NOT_IMPLEMENT_INTERFACE, "Return value of RTCPeerConnection.remoteDescription", "RTCSessionDescription");
          aRv.Throw(NS_ERROR_UNEXPECTED);
          return nullptr;
        }
      }
    }
  } else if (rval.isNullOrUndefined()) {
    rvalDecl = nullptr;
  } else {
    ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Return value of RTCPeerConnection.remoteDescription");
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  return rvalDecl.forget();
}

RTCSignalingState
RTCPeerConnectionJSImpl::GetSignalingState(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.signalingState", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return RTCSignalingState(0);
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->signalingState_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return RTCSignalingState(0);
  }
  RTCSignalingState rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, RTCSignalingStateValues::strings, "RTCSignalingState", "Return value of RTCPeerConnection.signalingState", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return RTCSignalingState(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<RTCSignalingState>(index);
  }
  return rvalDecl;
}

Nullable<bool>
RTCPeerConnectionJSImpl::GetCanTrickleIceCandidates(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.canTrickleIceCandidates", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return Nullable<bool>();
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->canTrickleIceCandidates_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<bool>();
  }
  Nullable<bool> rvalDecl;
  if (rval.isNullOrUndefined()) {
    rvalDecl.SetNull();
  } else if (!ValueToPrimitive<bool, eDefault>(cx, rval, &rvalDecl.SetValue())) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return Nullable<bool>();
  }
  return rvalDecl;
}

RTCIceGatheringState
RTCPeerConnectionJSImpl::GetIceGatheringState(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.iceGatheringState", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return RTCIceGatheringState(0);
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->iceGatheringState_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return RTCIceGatheringState(0);
  }
  RTCIceGatheringState rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, RTCIceGatheringStateValues::strings, "RTCIceGatheringState", "Return value of RTCPeerConnection.iceGatheringState", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return RTCIceGatheringState(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<RTCIceGatheringState>(index);
  }
  return rvalDecl;
}

RTCIceConnectionState
RTCPeerConnectionJSImpl::GetIceConnectionState(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.iceConnectionState", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return RTCIceConnectionState(0);
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->iceConnectionState_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return RTCIceConnectionState(0);
  }
  RTCIceConnectionState rvalDecl;
  {
    int index;
    if (!FindEnumStringIndex<true>(cx, rval, RTCIceConnectionStateValues::strings, "RTCIceConnectionState", "Return value of RTCPeerConnection.iceConnectionState", &index)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return RTCIceConnectionState(0);
    }
    MOZ_ASSERT(index >= 0);
    rvalDecl = static_cast<RTCIceConnectionState>(index);
  }
  return rvalDecl;
}

already_AddRefed<Promise>
RTCPeerConnectionJSImpl::GetPeerIdentity(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.peerIdentity", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->peerIdentity_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<Promise> rvalDecl;
  { // Scope for our GlobalObject, FastErrorResult, JSAutoCompartment,
    // etc.

    JS::Rooted<JSObject*> globalObj(cx, JS::CurrentGlobalOrNull(cx));
    if (!rval.isObject()) {
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.peerIdentity"));
      return nullptr;
    }
    JSObject* unwrappedVal = js::CheckedUnwrap(&rval.toObject());
    if (!unwrappedVal) {
      // A slight lie, but not much of one, for a dead object wrapper.
      aRv.ThrowTypeError<MSG_NOT_OBJECT>(NS_LITERAL_STRING("return value of RTCPeerConnection.peerIdentity"));
      return nullptr;
    }
    globalObj = js::GetGlobalForObjectCrossCompartment(unwrappedVal);
    JSAutoCompartment ac(cx, globalObj);
    GlobalObject promiseGlobal(cx, globalObj);
    if (promiseGlobal.Failed()) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }

    JS::Rooted<JS::Value> valueToResolve(cx, rval);
    if (!JS_WrapValue(cx, &valueToResolve)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    binding_detail::FastErrorResult promiseRv;
    nsCOMPtr<nsIGlobalObject> global =
      do_QueryInterface(promiseGlobal.GetAsSupports());
    if (!global) {
      promiseRv.Throw(NS_ERROR_UNEXPECTED);
      promiseRv.MaybeSetPendingException(cx);
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
    rvalDecl = Promise::Resolve(global, cx, valueToResolve,
                                    promiseRv);
    if (promiseRv.MaybeSetPendingException(cx)) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return nullptr;
    }
  }
  return rvalDecl.forget();
}

void
RTCPeerConnectionJSImpl::GetIdpLoginUrl(nsString& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.idpLoginUrl", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->idpLoginUrl_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  binding_detail::FakeString rvalDecl;
  if (!ConvertJSValueToString(cx, rval, eNull, eNull, rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = rvalDecl;
}

void
RTCPeerConnectionJSImpl::GetId(nsString& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.id", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->id_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  binding_detail::FakeString rvalDecl;
  if (!ConvertJSValueToString(cx, rval, eStringify, eStringify, rvalDecl)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
  aRetVal = rvalDecl;
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOnnegotiationneeded(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onnegotiationneeded", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->onnegotiationneeded_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOnicecandidate(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onicecandidate", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->onicecandidate_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOnsignalingstatechange(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onsignalingstatechange", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->onsignalingstatechange_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOnaddstream(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onaddstream", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->onaddstream_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOnaddtrack(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onaddtrack", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->onaddtrack_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOntrack(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.ontrack", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->ontrack_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOnremovestream(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onremovestream", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->onremovestream_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOniceconnectionstatechange(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.oniceconnectionstatechange", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->oniceconnectionstatechange_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnectionJSImpl::GetOndatachannel(ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.ondatachannel", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return nullptr;
  }
  JS::Rooted<JS::Value> rval(cx, JS::UndefinedValue());

  JS::Rooted<JSObject *> callback(cx, mCallback);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_GetPropertyById(cx, callback, atomsCache->ondatachannel_id, &rval)) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  RefPtr<EventHandlerNonNull> rvalDecl;
  if (rval.isObject()) {
      { // Scope for tempRoot
        JS::Rooted<JSObject*> tempRoot(cx, &rval.toObject());
        rvalDecl = new EventHandlerNonNull(cx, tempRoot, mozilla::dom::GetIncumbentGlobal());
      }
  } else {
    rvalDecl = nullptr;
  }
  return rvalDecl.forget();
}

void
RTCPeerConnectionJSImpl::SetId(const nsAString& arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.id", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    nsString mutableStr(arg);
    if (!xpc::NonVoidStringToJsval(cx, mutableStr, argv[0])) {
      aRv.Throw(NS_ERROR_UNEXPECTED);
      return;
    }
    break;
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->id_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOnnegotiationneeded(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onnegotiationneeded", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->onnegotiationneeded_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOnicecandidate(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onicecandidate", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->onicecandidate_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOnsignalingstatechange(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onsignalingstatechange", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->onsignalingstatechange_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOnaddstream(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onaddstream", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->onaddstream_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOnaddtrack(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onaddtrack", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->onaddtrack_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOntrack(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.ontrack", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->ontrack_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOnremovestream(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.onremovestream", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->onremovestream_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOniceconnectionstatechange(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.oniceconnectionstatechange", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->oniceconnectionstatechange_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}

void
RTCPeerConnectionJSImpl::SetOndatachannel(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  CallSetup s(this, aRv, "RTCPeerConnection.ondatachannel", eRethrowContentExceptions, aCompartment, /* aIsJSImplementedWebIDL = */ true);
  JSContext* cx = s.GetContext();
  if (!cx) {
    MOZ_ASSERT(aRv.Failed());
    return;
  }
  JS::AutoValueVector argv(cx);
  if (!argv.resize(1)) {
    aRv.Throw(NS_ERROR_OUT_OF_MEMORY);
    return;
  }
  do {
    if (arg) {
      argv[0].setObject(*GetCallbackFromCallbackObject(arg));
      if (!MaybeWrapObjectOrNullValue(cx, argv[0])) {
        aRv.Throw(NS_ERROR_UNEXPECTED);
        return;
      }
      break;
    } else {
      argv[0].setNull();
      break;
    }
  } while (0);

  MOZ_ASSERT(argv.length() == 1);
  RTCPeerConnectionAtoms* atomsCache = GetAtomCache<RTCPeerConnectionAtoms>(cx);
  if ((!*reinterpret_cast<jsid**>(atomsCache) && !InitIds(cx, atomsCache)) ||
      !JS_SetPropertyById(cx, CallbackKnownNotGray(), atomsCache->ondatachannel_id, argv[0])) {
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return;
  }
}


NS_IMPL_CYCLE_COLLECTION_INHERITED(RTCPeerConnection, mozilla::DOMEventTargetHelper, mImpl, mParent)
NS_IMPL_ADDREF_INHERITED(RTCPeerConnection, mozilla::DOMEventTargetHelper)
NS_IMPL_RELEASE_INHERITED(RTCPeerConnection, mozilla::DOMEventTargetHelper)
NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION_INHERITED(RTCPeerConnection)
NS_INTERFACE_MAP_END_INHERITING(mozilla::DOMEventTargetHelper)

RTCPeerConnection::RTCPeerConnection(JS::Handle<JSObject*> aJSImplObject, nsIGlobalObject* aParent)
  : mozilla::DOMEventTargetHelper(aParent),
    mImpl(new RTCPeerConnectionJSImpl(nullptr, aJSImplObject, /* aIncumbentGlobal = */ nullptr)),
    mParent(aParent)
{
}


RTCPeerConnection::~RTCPeerConnection()
{
}

nsISupports*
RTCPeerConnection::GetParentObject() const
{
  return mParent;
}

JSObject*
RTCPeerConnection::WrapObject(JSContext* aCx, JS::Handle<JSObject*> aGivenProto)
{
  JS::Rooted<JSObject*> obj(aCx, RTCPeerConnectionBinding::Wrap(aCx, this, aGivenProto));
  if (!obj) {
    return nullptr;
  }

  // Now define it on our chrome object
  JSAutoCompartment ac(aCx, mImpl->Callback());
  if (!JS_WrapObject(aCx, &obj)) {
    return nullptr;
  }
  if (!JS_DefineProperty(aCx, mImpl->Callback(), "__DOM_IMPL__", obj, 0)) {
    return nullptr;
  }
  return obj;
}

already_AddRefed<RTCPeerConnection>
RTCPeerConnection::Constructor(const GlobalObject& global, JSContext* cx, const RTCConfiguration& configuration, const Optional<JS::Handle<JSObject*>>& constraints, ErrorResult& aRv)
{
  JS::Rooted<JSObject*> jsImplObj(cx);
  nsCOMPtr<nsIGlobalObject> globalHolder =
    ConstructJSImplementation("@mozilla.org/dom/peerconnection;1", global, &jsImplObj, aRv);
  if (aRv.Failed()) {
    return nullptr;
  }
  // Build the C++ implementation.
  RefPtr<RTCPeerConnection> impl = new RTCPeerConnection(jsImplObj, globalHolder);
  // Wrap the object before calling __Init so that __DOM_IMPL__ is available.
  JS::Rooted<JSObject*> scopeObj(cx, globalHolder->GetGlobalJSObject());
  MOZ_ASSERT(js::IsObjectInContextCompartment(scopeObj, cx));
  JS::Rooted<JS::Value> wrappedVal(cx);
  if (!GetOrCreateDOMReflector(cx, impl, &wrappedVal)) {
    //XXX Assertion disabled for now, see bug 991271.
    MOZ_ASSERT(true || JS_IsExceptionPending(cx));
    aRv.Throw(NS_ERROR_UNEXPECTED);
    return nullptr;
  }
  // Initialize the object with the constructor arguments.
  impl->mImpl->__Init(configuration, constraints, aRv, js::GetObjectCompartment(scopeObj));
  if (aRv.Failed()) {
    return nullptr;
  }
  return impl.forget();
}

void
RTCPeerConnection::SetIdentityProvider(const nsAString& provider, const Optional<nsAString>& protocol, const Optional<nsAString>& username, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->SetIdentityProvider(provider, protocol, username, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::GetIdentityAssertion(ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetIdentityAssertion(aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::CreateOffer(const RTCOfferOptions& options, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->CreateOffer(options, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::CreateOffer(RTCSessionDescriptionCallback& successCallback, RTCPeerConnectionErrorCallback& failureCallback, const RTCOfferOptions& options, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->CreateOffer(successCallback, failureCallback, options, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::CreateAnswer(const RTCAnswerOptions& options, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->CreateAnswer(options, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::CreateAnswer(RTCSessionDescriptionCallback& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->CreateAnswer(successCallback, failureCallback, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::SetLocalDescription(RTCSessionDescription& description, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->SetLocalDescription(description, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::SetLocalDescription(RTCSessionDescription& description, VoidFunction& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->SetLocalDescription(description, successCallback, failureCallback, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::SetRemoteDescription(RTCSessionDescription& description, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->SetRemoteDescription(description, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::SetRemoteDescription(RTCSessionDescription& description, VoidFunction& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->SetRemoteDescription(description, successCallback, failureCallback, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<RTCSessionDescription>
RTCPeerConnection::GetLocalDescription(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetLocalDescription(aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<RTCSessionDescription>
RTCPeerConnection::GetRemoteDescription(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetRemoteDescription(aRv, aCompartment);
}

RTCSignalingState
RTCPeerConnection::GetSignalingState(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetSignalingState(aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::AddIceCandidate(RTCIceCandidate& candidate, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->AddIceCandidate(candidate, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::AddIceCandidate(RTCIceCandidate& candidate, VoidFunction& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->AddIceCandidate(candidate, successCallback, failureCallback, aRv, aCompartment);
}

Nullable<bool>
RTCPeerConnection::GetCanTrickleIceCandidates(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetCanTrickleIceCandidates(aRv, aCompartment);
}

RTCIceGatheringState
RTCPeerConnection::GetIceGatheringState(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetIceGatheringState(aRv, aCompartment);
}

RTCIceConnectionState
RTCPeerConnection::GetIceConnectionState(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetIceConnectionState(aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::GetPeerIdentity(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetPeerIdentity(aRv, aCompartment);
}

void
RTCPeerConnection::GetIdpLoginUrl(nsString& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetIdpLoginUrl(aRetVal, aRv, aCompartment);
}

void
RTCPeerConnection::GetId(nsString& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetId(aRetVal, aRv, aCompartment);
}

void
RTCPeerConnection::SetId(const nsAString& arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetId(arg, aRv, aCompartment);
}

void
RTCPeerConnection::GetConfiguration(RTCConfiguration& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetConfiguration(aRetVal, aRv, aCompartment);
}

void
RTCPeerConnection::GetLocalStreams(nsTArray<RefPtr<DOMMediaStream>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetLocalStreams(aRetVal, aRv, aCompartment);
}

void
RTCPeerConnection::GetRemoteStreams(nsTArray<RefPtr<DOMMediaStream>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetRemoteStreams(aRetVal, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<DOMMediaStream>
RTCPeerConnection::GetStreamById(const nsAString& streamId, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetStreamById(streamId, aRv, aCompartment);
}

void
RTCPeerConnection::AddStream(DOMMediaStream& stream, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->AddStream(stream, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<RTCRtpSender>
RTCPeerConnection::AddTrack(MediaStreamTrack& track, DOMMediaStream& stream, const Sequence<OwningNonNull<DOMMediaStream>>& moreStreams, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->AddTrack(track, stream, moreStreams, aRv, aCompartment);
}

void
RTCPeerConnection::RemoveTrack(RTCRtpSender& sender, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->RemoveTrack(sender, aRv, aCompartment);
}

void
RTCPeerConnection::GetSenders(nsTArray<RefPtr<RTCRtpSender>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetSenders(aRetVal, aRv, aCompartment);
}

void
RTCPeerConnection::GetReceivers(nsTArray<RefPtr<RTCRtpReceiver>>& aRetVal, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetReceivers(aRetVal, aRv, aCompartment);
}

void
RTCPeerConnection::MozSelectSsrc(RTCRtpReceiver& receiver, uint16_t ssrcIndex, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->MozSelectSsrc(receiver, ssrcIndex, aRv, aCompartment);
}

void
RTCPeerConnection::Close(ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->Close(aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOnnegotiationneeded(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOnnegotiationneeded(aRv, aCompartment);
}

void
RTCPeerConnection::SetOnnegotiationneeded(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOnnegotiationneeded(arg, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOnicecandidate(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOnicecandidate(aRv, aCompartment);
}

void
RTCPeerConnection::SetOnicecandidate(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOnicecandidate(arg, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOnsignalingstatechange(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOnsignalingstatechange(aRv, aCompartment);
}

void
RTCPeerConnection::SetOnsignalingstatechange(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOnsignalingstatechange(arg, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOnaddstream(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOnaddstream(aRv, aCompartment);
}

void
RTCPeerConnection::SetOnaddstream(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOnaddstream(arg, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOnaddtrack(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOnaddtrack(aRv, aCompartment);
}

void
RTCPeerConnection::SetOnaddtrack(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOnaddtrack(arg, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOntrack(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOntrack(aRv, aCompartment);
}

void
RTCPeerConnection::SetOntrack(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOntrack(arg, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOnremovestream(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOnremovestream(aRv, aCompartment);
}

void
RTCPeerConnection::SetOnremovestream(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOnremovestream(arg, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOniceconnectionstatechange(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOniceconnectionstatechange(aRv, aCompartment);
}

void
RTCPeerConnection::SetOniceconnectionstatechange(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOniceconnectionstatechange(arg, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::GetStats(const Optional<MediaStreamTrack*>& selector, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetStats(selector, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<Promise>
RTCPeerConnection::GetStats(MediaStreamTrack* selector, RTCStatsCallback& successCallback, RTCPeerConnectionErrorCallback& failureCallback, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->GetStats(selector, successCallback, failureCallback, aRv, aCompartment);
}

// Return a raw pointer here to avoid refcounting, but make sure it's safe (the object should be kept alive by the callee).
already_AddRefed<nsIDOMDataChannel>
RTCPeerConnection::CreateDataChannel(const nsAString& label, const RTCDataChannelInit& dataChannelDict, ErrorResult& aRv, JSCompartment* aCompartment)
{
  return mImpl->CreateDataChannel(label, dataChannelDict, aRv, aCompartment);
}

already_AddRefed<EventHandlerNonNull>
RTCPeerConnection::GetOndatachannel(ErrorResult& aRv, JSCompartment* aCompartment) const
{
  return mImpl->GetOndatachannel(aRv, aCompartment);
}

void
RTCPeerConnection::SetOndatachannel(EventHandlerNonNull* arg, ErrorResult& aRv, JSCompartment* aCompartment)
{
  mImpl->SetOndatachannel(arg, aRv, aCompartment);
}

bool
RTCPeerConnection::_Create(JSContext* cx, unsigned argc, JS::Value* vp)
{
  JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
  if (args.length() < 2) {
    return ThrowErrorMessage(cx, MSG_MISSING_ARGUMENTS, "RTCPeerConnection._create");
  }
  if (!args[0].isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 1 of RTCPeerConnection._create");
  }
  if (!args[1].isObject()) {
    return ThrowErrorMessage(cx, MSG_NOT_OBJECT, "Argument 2 of RTCPeerConnection._create");
  }

  // GlobalObject will go through wrappers as needed for us, and
  // is simpler than the right UnwrapArg incantation.
  GlobalObject global(cx, &args[0].toObject());
  if (global.Failed()) {
    return false;
  }
  nsCOMPtr<nsIGlobalObject> globalHolder = do_QueryInterface(global.GetAsSupports());
  MOZ_ASSERT(globalHolder);
  JS::Rooted<JSObject*> arg(cx, &args[1].toObject());
  RefPtr<RTCPeerConnection> impl = new RTCPeerConnection(arg, globalHolder);
  MOZ_ASSERT(js::IsObjectInContextCompartment(arg, cx));
  return GetOrCreateDOMReflector(cx, impl, args.rval());
}


} // namespace dom
} // namespace mozilla
